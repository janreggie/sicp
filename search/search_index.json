{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SICP Exercises \u00b6 Solutions for exercises for the book \"Structures and Interpretations of Computer Programs\" by Abelson and Sussman.","title":"SICP Exercises"},{"location":"#sicp-exercises","text":"Solutions for exercises for the book \"Structures and Interpretations of Computer Programs\" by Abelson and Sussman.","title":"SICP Exercises"},{"location":"1-building-abstractions-using-procedures/","text":"Building Abstractions Using Procedures \u00b6 1.1 The Elements of Programming \u00b6 Exercise 1.1 \u00b6 10 ; 10 (+ 5 3 4) ; 12 (- 9 1) ; 8 (/ 6 2) ; 3 (+ (* 2 4) (- 4 6)) ; 6 (define a 3) ; a = 3 (define b (+ a 1)) ; b = 4 (+ a b (* a b)) ; 19 (= a b) ; #f (if (and (> b a) (< b (* a b))) b a) ; 4 (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) ; (+ 6 7 a) => 16 (+ 2 (if (> b a) b a)) ; 6 (* (cond ((> a b) a) ((< a b) b) (else -1)) (+ a 1)) ; 16 Exercise 1.2 \u00b6 (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7))) Exercise 1.3 \u00b6 ; sum-of-squares takes in two numbers and returns the sum of their squares (define (sum-of-squares a b) (+ (* a a) (* b b))) ; exercise-1-3 takes in three numbers ; and returns the sum of squares of the two larger numbers (define (exercise-1-3 a b c) ( cond ((and (< b a) (< b c)) (sum-of-squares a c)) ((and (< a b) (< a c)) (sum-of-squares b c)) (else (sum-of-squares a b)) ) ) Exercise 1.4 \u00b6 (define (a-plus-abs-b a b) ((if (> b 0) + -) a b)) ; the operator changes depending on the value of the if statement!! ; if b>0 return a+b otherwise return a-b (which turns b positive and adds it to a) Exercise 1.5 \u00b6 (define (p) (p)) ; a recursive function (don't execute this!!) (define (test x y) (if (= x 0) 0 y)) (test 0 (p)) ; don't run this on applicative-order systems On normal-order evaluation, the expression (test 0 (p)) first expands to (if (= 0 0) 0 (p)) , which will be evaluated to 0 . On applicative-order evaluation, the expression (test 0 (p)) will have (p) expanded to... (p) , and then expanded to (p) recursively, leading to no real work being done. Exercise 1.6 \u00b6 Substituting this new-if function in the procedure causes a maximum recursion depth exceeded error, even for an input of 1 . Why? (sqrt 1) ; ==> (sqrt-iter 1.0 1) ; ==> (new-if (good-enough? 1.0 1) 1.0 (sqrt-iter (improve guess x) x)) Here lies the kicker. Before new-if gets substituted, it first has to evaluate the arguments (good-enough? 1.0 1) , which easily evaluates to #t , and (sqrt-iter (improve guess x) x) , which does a recursive loop. The stack continues to grow until maximum recursion depth is reached. Exercise 1.7 \u00b6 ; eval-sqrt evaluates the sqrt function for a number (define (eval-sqrt x) (- (square (sqrt x)) x)) (eval-sqrt 4.64e-35) ; ==> .0009765625, or 9.765625e-4 (eval-sqrt 104828495672) ; ==> -.0000152587890625 Notice two things here. The first one is that the evaluation of the square root of the very small number has a ridiculously large error, where it is off by several orders of magnitude. (The real value of the square root is 6.8117e-18.) This is expected since good-enough checks if the difference between the values is less than some constant threshold: good for most cases, but bad for numbers that are smaller than said threshold. The second one is that there is always some amount of error when dealing with floating point numbers, as shown in the second example. Some precision will always be lost when dealing with floats. Redefining good-enough to check relative to guess : ; good-enough checks if the difference between the current and next guess ; is less than 0.0001% of the current value of guess (define (good-enough guess x) (< (abs (- guess (improve guess x))) (/ guess 100000))) (eval-sqrt 4.64e-35) ; ==> 2.800177998007718e-41 (eval-sqrt 104828495672) ; ==> 991925.5386352539 While the value for error might seem much larger for large numbers, running (sqrt 104828495672) yields 323773.8216680568, not too far off from the real value of 323772.289846. In addition, running (sqrt 4.64e-35) yields 6.811756601771674e-18, really close to the actual value. Exercise 1.8 \u00b6 ; cbrt solves the cube root using Newton's method (define (cbrt x) (define (cbrt-iter guess x) (if (cbrt-goodenough guess x) guess (cbrt-iter (cbrt-improve guess x) x))) (define (cbrt-improve guess x) (/ (+ (/ x (* guess guess)) (* 2 guess)) 3)) (define (cbrt-goodenough guess x) (< (abs (- guess (cbrt-improve guess x))) (/ guess 100000))) (cbrt-iter 1.0 x)) (cbrt 27) ; ==> 3.0000005410641766 1.2 Procedures and the Processes they Generate \u00b6 Exercise 1.9 \u00b6 Supposing inc and dec are increment and decrement operators respectively, there is a difference how these two functions work: ; First process (define (+ a b) (if (= a 0) b (inc (+ (dec a) b)))) (+ 4 5) ; (inc (+ (dec 4) 5)) ; (inc (+ 3 5)) ; (inc (inc (+ (dec 3) 5))) ; (inc (inc (+ 2 5))) ; (inc (inc (inc (+ (dec 2) 5)))) ; (inc (inc (inc (+ 1 5)))) ; (inc (inc (inc (inc (+ (dec 1) 5))))) ; (inc (inc (inc (inc (+ 0 5))))) ; (inc (inc (inc (inc 5)))) ; (inc (inc (inc 6))) ; (inc (inc 7)) ; (inc 8) ; (9) ; Second process (define (+ a b) (if (= a 0) b (+ (dec a) (inc b)))) (+ 4 5) ; (+ (dec 4) (inc 5)) ; (+ 3 6) ; (+ (dec 3) (inc 6)) ; (+ 2 7) ; (+ (dec 2) (inc 7)) ; (+ 1 8) ; (+ (dec 1) (inc 8)) ; (+ 0 9) ; (9) The first process can be characterized as recursive since a chain of operations can be seen growing after every call, while the second can be characterized as iterative as the chain of operations does not grow or shrink, and the state is maintained by the parameters it contains. Exercise 1.10 \u00b6 Consider Ackermann's function: (define (A x y) (cond ((= y 0) 0) ((= x 0) (* 2 y)) ((= y 1) 2) (else (A (- x 1) (A x (- y 1)))))) From here, we see that f such that (define (f n) (A 0 n)) would just be \\(f\\left(n\\right)=2n\\) . (A 1 10) ; (A (- 1 1) (A 1 (- 10 1))) ; (A 0 (A 1 9)) ; (A 0 (A (- 1 1) (A 1 (- 9 1)))) ; (A 0 (A 0 (A 1 8))) ; (A 0 (A 0 (A (- 1 1) (A 1 (- 8 1))))) ; (A 0 (A 0 (A 0 (A 1 7)))) ; (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 7 1)))))) ; (A 0 (A 0 (A 0 (A 0 (A 1 6))))) ; (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 6 1))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5)))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 5 1)))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 4 1))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3)))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 3 1)))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 2 1))))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1)))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 2))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4)))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 4)))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 8))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16)))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 16)))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 32))))) ; (A 0 (A 0 (A 0 (A 0 (* 2 32))))) ; (A 0 (A 0 (A 0 (A 0 64)))) ; (A 0 (A 0 (A 0 (* 2 64)))) ; (A 0 (A 0 (A 0 128))) ; (A 0 (A 0 (* 2 128))) ; (A 0 (A 0 256)) ; (A 0 (* 2 256)) ; (A 0 512) ; (* 2 0 512) ; (1024) Hypothesize that g such that (define (g n) (A 1 n)) equals \\(g\\left(n\\right)=2^n\\) . This can be proved using induction: suppose \\(A\\left(1,n\\right)=2^n\\) , and prove that \\(A\\left(1,n+1\\right)=2^{n+1}\\) . \\[ \\begin{aligned} A\\left(1,n+1\\right) &= A\\left(1-1, A\\left(1, \\left(n+1\\right)-1\\right)\\right) \\\\ &= A\\left(0, A\\left(1, n\\right)\\right) \\\\ &= 2\\cdot A\\left(1,n\\right) \\\\ &= 2\\cdot2^n \\\\ &= 2^{n+1} \\end{aligned} \\] (A 2 4) ; (A (- 2 1) (A 2 (- 4 1))) ; (A 1 (A 2 3)) ; (A 1 (A (- 2 1) (A 2 (- 3 1)))) ; (A 1 (A 1 (A 2 2))) ; (A 1 (A 1 (A (- 2 1) (A 2 (- 2 1))))) ; (A 1 (A 1 (A 1 (A 2 1)))) ; (A 1 (A 1 (A 1 2))) From our previous definition of g , we can say that the expression (A 1 (A 1 (A 1 2))) solves to \\(2^{2^{2^2}}\\) , although writing down the steps to getting there will be hell an exercise left to the reader. Hypothesize that h such that (define (h n) (A 2 n)) equals \\(h\\left(n\\right)=2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}}\\) , such that the number of \\(2\\) equals \\(n\\) . This also can be proved using induction: suppose \\(A\\left(2,n\\right)=2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}} \\rbrace\\text{n-many 2's}\\) , and prove that \\(A\\left(2,n+1\\right)\\) results to \\(n+1\\) twos: \\[ \\begin{aligned} A\\left(2,n+1\\right) &= A\\left(2-1, A\\left(2, \\left(n+1\\right)-1\\right)\\right) \\\\ &= A\\left(1,A\\left(2,n\\right)\\right) \\\\ % why do i even bother... &= A\\left(1, \\left.2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}}\\right\\rbrace\\text{$n$-many 2's}\\right) \\\\ &= 2^{\\left.2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}}\\right\\rbrace\\text{$n$-many 2's}} \\\\ &= \\left.2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}}\\right\\rbrace\\text{$n+1$-many 2's} \\end{aligned} \\] Exercise 1.11 \u00b6 Writing the recursive implementation is trivial: (define (f n) (if (< n 3) n (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3)))))) (f 30) ; ==> 61354575194 (will take a long time to compute) Writing an iterative implementation is a bit more difficult. Consider that, ultimately, f is evaluated as a sum of three numbers, and these three numbers can be used as a state. (define (f n) ; iter is the iterative process wherein (a, b, c) <- (a+2b+3c, a, b). ; if count == 0, return a (define (iter a b c count) (if (= count 0) a (iter (+ a (* 2 b) (* 3 c)) a b (- count 1)))) (if (< n 3) n (iter 2 1 0 (- n 2))) ; 2 as an offset ) (f 30) ; ==> 61354575194 (didn't take that long at all!) Exercise 1.12 \u00b6 ; pascal returns the cnt'th number (start from zero) ; at the row'th row (0: 1, 1: 1,1, 2: 1,2,1). (define (pascal row cnt) (cond ((or (< cnt 0) (> cnt row)) 0) ((or (= cnt 0) (= cnt row)) 1) (else (+ (pascal (- row 1) (- cnt 1)) (pascal (- row 1) cnt)) ) ) ) (pascal 4 2) Exercise 1.13 \u00b6 Initially, let us prove that \\(F\\left(n\\right) = \\frac{\\phi^n - \\psi^n}{\\sqrt{5}}\\) , where \\(F\\left(n\\right)\\) is the \\(n\\) 'th Fibonacci number and \\(\\phi=\\frac{1+\\sqrt{5}}{2}, \\psi=\\frac{1-\\sqrt{5}}{2}\\) , via induction. The base cases for \\(F\\left(0\\right)\\) and \\(F\\left(1\\right)\\) is shown to be 0 and 1. A proof is left as an exercise to the reader. Suppose that \\(F\\) follows up to \\(n-1\\) . Let us then prove that \\(F\\left(n\\right)\\) holds. \\[ \\begin{aligned} F\\left(n\\right) &= F\\left(n-1\\right) + F\\left(n-2\\right) \\\\ &= \\frac{\\phi^\\left(n-1\\right) - \\psi^\\left(n-1\\right)}{\\sqrt{5}} + \\frac{\\phi^\\left(n-2\\right) - \\psi^\\left(n-2\\right)}{\\sqrt{5}} \\\\ &= \\frac{\\left(\\phi+1\\right) \\phi^\\left(n-2\\right) - \\left(\\psi+1\\right) \\psi^\\left(n-2\\right)}{\\sqrt{5}} \\\\ &= \\frac{\\frac{3+\\sqrt{5}}{2} \\phi^\\left(n-2\\right) - \\frac{3-\\sqrt{5}}{2} \\psi^\\left(n-2\\right)}{\\sqrt{5}} && \\text{Note that $\\frac{3\\pm\\sqrt{5}}{2}=\\left(\\frac{1\\pm\\sqrt{5}}{2}\\right)^2$} \\\\ &= \\frac{\\phi^2 \\phi^\\left(n-2\\right) - \\psi^2 \\psi^\\left(n-2\\right)}{\\sqrt{5}} \\\\ &= \\frac{\\phi^n - \\psi^n}{\\sqrt{5}} \\end{aligned} \\] Note that \\(\\psi\\approx-0.618\\) and \\(\\psi^n\\) approaches zero. Therefore, \\(\\frac{\\phi^n}{\\sqrt{5}}\\) is \"close enough\" to \\(\\frac{\\phi^n - \\psi^n}{\\sqrt{5}}\\) . Exercise 1.14 \u00b6 Paths leading to a red node are unwanted, whereas paths leading to a green node are desired. Note that multiple sections of the tree repeat itself, which is why a node can have more than two paths coming towards it. An increment to amount increases the number of operations exponentially, and increases the number of nodes to compute linearly. Exercise 1.15 \u00b6 (define (cube x) (* x x x)) (define (p x) (- (* 3 x) (* 4 (cube x)))) (define (sine angle) (if (not (> (abs angle) 0.1)) angle (p (sine (/ angle 3.0))))) (sine 12.15) ; (/ angle 3.0) and (p x) operations have been substituted ; (p (sine 4.05)) ; (p (p (sine 1.35))) ; (p (p (p (sine 0.45)))) ; (p (p (p (p (sine 0.15))))) ; (p (p (p (p (p (sine 0.05)))))) ; (p (p (p (p (p 0.05))))) ; (p (p (p (p 0.1495)))) ; (p (p (p 0.4351))) ; (p (p 0.9758)) ; (p -0.7892) ; -0.4044 The p procedure has been applied five times. Considering that p can be solved in constant time and occupies constant space, the order of growth in space and the number of steps for \\(p\\left(a\\right)\\) is \\(\\Theta\\left(\\lg n\\right)\\) . This can be shown by noticing that \\(p\\left(3a\\right)\\) requires a constant number of operations more than \\(p\\left(a\\right)\\) , for instance, the amount of space and operations for (sine 1.35) versus that of (sine 4.05) . Exercise 1.16 \u00b6 ; expt is an exponential function that returns b raised to n. ; note that this shadows the built-in expt. (define (expt b n) (define (even? n) (= (remainder n 2) 0)) (define (halve n) (/ n 2)) (define (square n) (* n n)) ; exptiter iterates thru a, b, and n until b equals 1, and then the result is located in a. ; a must be initialized to 1. (define (exptiter a b n) (cond ((= n 0) a) ((even? n) (exptiter a (square b) (halve n))) (else (exptiter (* a b) b (- n 1))))) (exptiter 1 b n)) (expt 3 5) ; ==> 243 Exercise 1.17 \u00b6 (define (mul a b) (define (even? n) (= (remainder n 2) 0)) (define (halve n) (/ n 2)) (define (double n) (+ n n)) (cond ((= b 0) 0) ((= b 1) a) ((even? b) (mul (double a) (halve b))) (else (+ a (mul a (- b 1)))))) (mul 9 6) ; ==> 54 Exercise 1.18 \u00b6 (define (mul a b) (define (even? n) (= (remainder n 2) 0)) (define (halve n) (/ n 2)) (define (double n) (+ n n)) (define (multiter a b result) (cond ((= b 0) result) ((even? b) (multiter (double a) (halve b) result)) (else (multiter a (- b 1) (+ result a))))) (multiter a b 0)) (mul 9 6) ; ==> 54 Exercise 1.19 \u00b6 Note that \\(a, b \\xleftarrow{T\\left(p,q\\right)} bq+aq+ap, bp+aq = a\\left(p+q\\right)+bq, aq+bp\\) . With some algebra, \\[ \\begin{aligned} a, b &\\xleftarrow{T^2\\left(p,q\\right)} \\left(ap^2+2apq+2bpq+2aq^2+bq^2\\right), \\left(bp^2+2apq+aq^2+bq^2\\right) \\\\ &\\xleftarrow{T^2\\left(p,q\\right)} a\\left(p^2+2pq+2q^2\\right)+b\\left(2pq+q^2\\right), a\\left(2pq+q^2\\right)+b\\left(p^2+q^2\\right) \\\\ T^2\\left(p,q\\right) &= T\\left(p^2+q^2, 2pq+q^2\\right) \\end{aligned} \\] (define (fib n) (define (even? n) (= (remainder n 2) 0)) (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b (+ (* p p) (* q q)) (+ (* 2 p q) (* q q)) (/ count 2))) (else (fib-iter (+ (* b p) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1))))) (fib-iter 1 0 0 1 n)) (fib 35) ; ==> 9227465 Exercise 1.20 \u00b6 (define (gcd a b) (if (= b 0) a (gcd b (remainder a b)))) (gcd 206 40) ; for normal-order evaluation (18 remainder operations) ; (gcd 206 40) ; (if (= 40 0) 206 (gcd 40 (remainder 206 40))) ; (gcd 40 (remainder 206 40)) ; (if (= (remainder 206 40) 0) 40 (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (if (= 6 0) ; remainder +1 ; 40 ; (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (gcd (remainder 206 40) (remainder 40 (remainder 206 40))) ; (if (= (remainder 40 (remainder 206 40)) 0) ; (remainder 206 40) ; (gcd ; (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; (if (= 4 0) ; remainder +2 ; (remainder 206 40) ; (gcd ; (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; (gcd ; (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) ; (remainder 40 (remainder 206 40)) ; (gcd ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))) ; (if (= 2 0) ; remainder +4 ; (remainder 40 (remainder 206 40)) ; (gcd ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))) ; (gcd ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; (if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (gcd ; (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))) ; (if (= 0 0) ; remainder +7 ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (gcd ; (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; ==> 2 ; remainder +4 ; for applicative-order evaluation (4 remainder operations) ; (gcd 206 40) ; (if (= 40 0) 206 (gcd 40 (remainder 206 40))) ; (gcd 40 6) ; remainder +1 ; (if (= 6 0) 40 (gcd 6 (remainder 40 6))) ; (gcd 6 4) ; remainder +1 ; (if (= 4 0) 6 (gcd 4 (remainder 6 4))) ; (gcd 4 2) ; remainder +1 ; (if (= 2 0) 4 (gcd 2 (remainder 4 2))) ; (gcd 2 0) ; remainder +1 ; (if (= 0 0) 2 (gcd 2 (remainder 0 0))) ; ==> 2 Exercise 1.21 \u00b6 (define (smallest-divisor n) (define (divides? a b) (= (remainder b a) 0)) (define (square n) (* n n)) (define (find-divisor n test-divisor) (cond ((> (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (find-divisor n 2)) (smallest-divisor 199) ; (find-divisor 199 2) ; (find-divisor 199 3) ; ... ; (find-divisor 199 15) ; ==> 199 A similar event happens for 1999 where find-diivisor exhausts test-divisor from 2 to 45, and since the square of 45 is larger than 1999, it gives up and returns 1999. For 19999, when test-divisor becomes 7, (divides? 7 19999) returns #t and the iterative process stops and returns 7. Exercise 1.22 \u00b6 Because computing for primes larger than a million seems to be nearly instantaneous in modern hardware, I decided to increase their values by several orders of magnitude. ; search-for-primes prints out `count` number of primes from (including) `from`. ; If `count` <= 0 terminate the search. ; If from <= 1 set from to 2 (define (search-for-primes from count) (define (even? n) (= (remainder n 2) 0)) ; prime? checks for primality (define (prime? n) (define (smallest-divisor n) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (cond ((> (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (find-divisor n 2)) (= n (smallest-divisor n))) ; timed-prime? prints a message and returns true if n is prime; returns false otherwise (define (timed-prime? n) (define (start-prime-test n start-time) (if (prime? n) (report-prime (- (runtime) start-time)) #f)) (define (report-prime elapsed-time) (newline) (display n) (display \" is a prime\") (display \" *** \") (display elapsed-time) #t) (start-prime-test n (runtime))) (define (search-for-primes-iter n c) (cond ((= c 0) 0) ((timed-prime? n) (search-for-primes-iter (+ n 2) (- c 1))) (else (search-for-primes-iter (+ n 2) c)))) (cond ((<= count 0) 0) ((<= from 2) (search-for-primes-iter 3 (- count 1))) ((even? from) (search-for-primes-iter (+ from 1) count)) (else (search-for-primes-iter from count)))) ; increase by sqrt(10) per iteration (search-for-primes 1000000000 3) ; 1000000007 is a prime *** .06 ; 1000000009 is a prime *** .07 ; 1000000021 is a prime *** .06 (search-for-primes 3162280000 3) ; 3162280001 is a prime *** .07999999999999996 ; 3162280049 is a prime *** .07000000000000006 ; 3162280063 is a prime *** .07999999999999996 (search-for-primes 10000000000 3) ; 10000000019 is a prime *** .1100000000000001 ; 10000000033 is a prime *** .14 ; 10000000061 is a prime *** .1299999999999999 (search-for-primes 31622800000 3) ; 31622800021 is a prime *** .21999999999999997 ; 31622800031 is a prime *** .21999999999999997 ; 31622800037 is a prime *** .2100000000000002 (search-for-primes 100000000000 3) ; 100000000003 is a prime *** .3999999999999997 ; 100000000019 is a prime *** .3799999999999999 ; 100000000057 is a prime *** .36999999999999966 (search-for-primes 316228000000 3) ; 316228000021 is a prime *** .6600000000000001 ; 316228000051 is a prime *** .6699999999999999 ; 316228000057 is a prime *** .6699999999999999 (search-for-primes 1000000000000 3) ; 1000000000039 is a prime *** 1.17 ; 1000000000061 is a prime *** 1.17 ; 1000000000063 is a prime *** 1.1900000000000004 (search-for-primes 3162280000000 3) ; 3162280000021 is a prime *** 2.1000000000000014 ; 3162280000043 is a prime *** 2.41 ; 3162280000109 is a prime *** 2.25 (search-for-primes 10000000000000 3) ; 10000000000037 is a prime *** 3.759999999999998 ; 10000000000051 is a prime *** 3.75 ; 10000000000099 is a prime *** 3.7600000000000016 Notice that when the numbers incrases by two orders of magnitude (every four iterations), the time it takes increases by one order of magnitude. That is, \\(T\\left(100n\\right) \\approx 10T\\left(n\\right)\\) This satisfies \\(\\Theta\\left(T\\left(n\\right)\\right) = \\Theta\\left(\\sqrt{n}\\right)\\) . Exercise 1.23 \u00b6 The prime? function in the above code is replaced with as follows: (define (search-for-primes from count) ; ... code above goes here ; prime? checks for primality (define (prime? n) (define (smallest-divisor n) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (define (next divisor) (if (= divisor 2) 3 (+ divisor 2))) (cond ((> (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (next test-divisor))))) (find-divisor n 2)) (= n (smallest-divisor n))) ; ... code below goes here ) (search-for-primes 1000000000 3) ; 1000000007 is a prime *** 3.0000000000000027e-2 ; 1000000009 is a prime *** .03999999999999998 ; 1000000021 is a prime *** .02999999999999997 (search-for-primes 3162280000 3) ; 3162280001 is a prime *** 5.0000000000000044e-2 ; 3162280049 is a prime *** .06 ; 3162280063 is a prime *** 5.0000000000000044e-2 (search-for-primes 10000000000 3) ; 10000000019 is a prime *** .10000000000000009 ; 10000000033 is a prime *** .08999999999999997 ; 10000000061 is a prime *** .09999999999999998 (search-for-primes 31622800000 3) ; 31622800021 is a prime *** .15000000000000002 ; 31622800031 is a prime *** .16999999999999993 ; 31622800037 is a prime *** .21999999999999997 (search-for-primes 100000000000 3) ; 100000000003 is a prime *** .28 ; 100000000019 is a prime *** .28 ; 100000000057 is a prime *** .2599999999999998 (search-for-primes 316228000000 3) ; 316228000021 is a prime *** .46999999999999975 ; 316228000051 is a prime *** .45999999999999996 ; 316228000057 is a prime *** .46999999999999975 (search-for-primes 1000000000000 3) ; 1000000000039 is a prime *** .81 ; 1000000000061 is a prime *** .8399999999999999 ; 1000000000063 is a prime *** .8399999999999999 (search-for-primes 3162280000000 3) ; 3162280000021 is a prime *** 1.490000000000001 ; 3162280000043 is a prime *** 1.5500000000000007 ; 3162280000109 is a prime *** 1.4700000000000006 (search-for-primes 10000000000000 3) ; 10000000000037 is a prime *** 2.7299999999999986 ; 10000000000051 is a prime *** 2.6799999999999997 ; 10000000000099 is a prime *** 3.0100000000000016 Using linear regression, we can say that the time it takes for primes to be evaluated is roughly 73% of the original time. Removing even numbers as candidate divisors reduced the amount of time to compute by 27%. This is different from the 50% reduction that would have been expected by removing 50% of the candidate divisors. This is perhaps attributed to the time it takes for next to be evaluated, and the if function inside it. Exercise 1.24 \u00b6 (define (search-for-primes from count) ; ... code above goes here ; fast-prime? checks for primality using Fermat's little theorem (define (fast-prime? n times) (define (fermat-test n) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1))))) (cond ((= times 0) true) ((fermat-test n) (fast-prime? n (- times 1))) (else false))) ; timed-prime? prints a message and returns true if n is prime according to fast-prime; returns false otherwise (define (timed-prime? n) (define (start-prime-test n start-time) (if (fast-prime? n 100) (report-prime (- (runtime) start-time)) #f)) (define (report-prime elapsed-time) (newline) (display n) (display \" is a prime\") (display \" *** \") (display elapsed-time) #t) (start-prime-test n (runtime))) ; ... code below goes here ) ; incrase by sqrt(10) per iteration (search-for-primes 1000000000 3) ; 1000000007 is a prime *** 1.0000000000000009e-2 ; 1000000009 is a prime *** 1.0000000000000009e-2 ; 1000000021 is a prime *** 1.0000000000000009e-2 (search-for-primes 3162280000 3) ; 3162280001 is a prime *** 9.999999999999953e-3 ; 3162280049 is a prime *** 1.0000000000000009e-2 ; 3162280063 is a prime *** 1.0000000000000009e-2 (search-for-primes 10000000000 3) ; 10000000019 is a prime *** 1.0000000000000009e-2 ; 10000000033 is a prime *** 1.9999999999999962e-2 ; 10000000061 is a prime *** 2.0000000000000018e-2 (search-for-primes 31622800000 3) ; 31622800021 is a prime *** 2.0000000000000018e-2 ; 31622800031 is a prime *** 1.0000000000000009e-2 ; 31622800037 is a prime *** 1.9999999999999962e-2 (search-for-primes 100000000000 3) ; 100000000003 is a prime *** 1.0000000000000009e-2 ; 100000000019 is a prime *** 1.0000000000000009e-2 ; 100000000057 is a prime *** 1.0000000000000009e-2 (search-for-primes 316228000000 3) ; 316228000021 is a prime *** 1.9999999999999962e-2 ; 316228000051 is a prime *** 1.0000000000000009e-2 ; 316228000057 is a prime *** 2.0000000000000018e-2 (search-for-primes 1000000000000 3) ; 1000000000039 is a prime *** 0. ; 1000000000061 is a prime *** 1.0000000000000009e-2 ; 1000000000063 is a prime *** 1.0000000000000009e-2 (search-for-primes 3162280000000 3) ; 3162280000021 is a prime *** 1.9999999999999907e-2 ; 3162280000043 is a prime *** 1.0000000000000009e-2 ; 3162280000109 is a prime *** 3.0000000000000027e-2 (search-for-primes 10000000000000 3) ; 10000000000037 is a prime *** 1.0000000000000009e-2 ; 10000000000051 is a prime *** 2.0000000000000018e-2 ; 10000000000099 is a prime *** 1.0000000000000009e-2 Computing for prime numbers feels nearly instantaneous. Much, much larger numbers may need to be used here. (search-for-primes 1000000000000000000000000000 3) ; 1000000000000000000000000103 is a prime *** .02999999999999997 ; 1000000000000000000000000279 is a prime *** 1.9999999999999962e-2 ; 1000000000000000000000000283 is a prime *** 3.0000000000000027e-2 (search-for-primes 1000000000000000000000000000000000000000000000000000000 3) ; 1000000000000000000000000000000000000000000000000000031 is a prime *** .07999999999999996 ; 1000000000000000000000000000000000000000000000000000157 is a prime *** 5.0000000000000044e-2 ; 1000000000000000000000000000000000000000000000000000169 is a prime *** .07000000000000006 (search-for-primes 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 3) ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000019 is a prime *** .16999999999999993 ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001141 is a prime *** .1399999999999999 ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001207 is a prime *** .1399999999999999 (search-for-primes 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 3) ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000499 is a prime *** .43999999999999995 ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001107 is a prime *** .4500000000000002 ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001591 is a prime *** .4500000000000002 After each iteration the base is squared, leading to a near tripling of checking time: \\(T\\left(n^2\\right) \\approx 3T\\left(n\\right)\\) . This satisfies \\(\\Theta\\left(T\\left(n\\right)\\right)=\\Theta\\left(\\log n\\right)\\) . Exercise 1.25 \u00b6 The original procedure is as follows: (define (expmod base exp m) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)))) and the modified is as follows: (define (expmod base exp m) (remainder (fast-expt base exp) m)) The issue here is that (fast-expt ...) has to be evaluated first, and base and exp can be ridiculously high. After all of that, its remainder when divided by m is computed, and all that computational power might have been wasted. The original keeps the working value no more than m , and this is indicated by the remainder operation after every step. Exercise 1.26 \u00b6 \"...you have transformed the \\(\\Theta\\left(\\log n\\right)\\) process into a \\(\\Theta\\left(n\\right)\\) process.\" Consider first why the square procedure is being used. This is to avoid computing the value twice, as (expmod base (/ exp 2) m) would have already been evaluated and stored somewhere, and what is left to be done is to multiply its value by itself. By using (* (expmod base (/ exp 2) m) (expmod base (/ exp 2) m)) , computation would be done twice every recursive call. By doubling exp , the number of calls it takes to compute will then double, compared to just increasing by one if square were used. This can be proven using induction. Suppose that expmod takes \\(T\\left(n\\right)\\) time to compute where \\(n\\) is our exp . If we double exp , the time it takes for the (remainder (* ...)) code to run will be \\(2T\\left(n\\right)\\) , since each expmod call takes \\(T\\left(n\\right)\\) . Because of this linear relationship, \\(\\Theta\\left(T\\left(n\\right)\\right)=\\Theta\\left(n\\right)\\) Exercise 1.27 \u00b6 (define (test-camichael n) (define (expmod base exp m) (define (even? n) (= (remainder n 2) 0)) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)))) ; test-camichael-recursive tests for every a < n. Once `a` reaches `n` return true. (define (test-camichael-recursive a n) (cond ((= a n) #t) ((not (= (expmod a n n) a)) #f) (else (test-camichael-recursive (+ a 1) n)))) (test-camichael-recursive 2 n)) (test-camichael 561) ; ==> #t (test-camichael 1105) ; ==> #t (test-camichael 1729) ; ==> #t (test-camichael 2465) ; ==> #t (test-camichael 2821) ; ==> #t (test-camichael 6601) ; ==> #t Exercise 1.28 \u00b6 ; miller-rabin checks if n is prime (define (miller-rabin n) ; expmod is special. ; It returns 0 if it detects a \"nontrivial square root of 1 mod n\" (define (expmod base exp m) (define (special-case n) ; if-nsr-then-zero checks if n is a non-trivial square root of 1 mod m and returns zero if so (define (if-nsr-then-zero n sq) (define (neq a b) (not (= a b))) (if (and (neq n 1) (neq n (- m 1)) (= sq 1)) 0 sq)) (if-nsr-then-zero n (remainder (square n) m))) (define (even? n) (= (remainder n 2) 0)) (define (square n) (* n n)) (cond ((= exp 0) 1) ((even? exp) (special-case (expmod base (/ exp 2) m))) (else (remainder (* base (expmod base (- exp 1) m)) m)))) (define (test n) (define (try-it a) (= (expmod a (- n 1) n) 1)) (try-it (+ 1 (random (- n 1))))) (define (test-times times) (cond ((= times 0) #t) ((test n) (test-times (- times 1))) (else #f))) (test-times 3)) ; non-primes (miller-rabin 2821) ; ==> #f (miller-rabin 1105) ; ==> #f (miller-rabin 1729) ; ==> #f (miller-rabin 2465) ; ==> #f (miller-rabin 2821) ; ==> #f (miller-rabin 6601) ; ==> #f ; primes (miller-rabin 3162280000021) ; ==> #t (miller-rabin 3162280000043) ; ==> #t (miller-rabin 3162280000109) ; ==> #t 1.3 Formulating Abstractions with Higher-Order Procedures \u00b6 Exercise 1.29 \u00b6 ; simpson performs a Simpson's Rule integration of f from a to b. ; n denotes accuracy (and is implicitly turned even) (define (simpson f a b n) (define m (if (= 1 (remainder n 2)) (+ n 1) n)) ; \"new n\" (define h (/ (- b a) n)) ; we'll turn it into a floating-point later (define (y k) (f (+ a (* k h)))) (define (add-two x) (+ x 2)) (* (/ h 3.0) (+ (y 0) (y n) (* 4 (sum y 1 add-two (- m 1))) (* 2 (sum y 2 add-two (- m 2)))))) (simpson cube 0 1 1000) ; ==> 0.25 Exercise 1.30 \u00b6 (define (sum term a next b) (define (iter a result) (if (> a b) result (iter (next a) (+ result (term a))))) (iter a 0)) Exercise 1.31 \u00b6 (define (product term a next b) (if (> a b) 1 (* (term a) (product term (next a) next b)))) ; approx-pi evaluates pi to some accuracy level n (define (approx-pi n) (define (inc n) (+ n 1)) ; term n is as follows: (term 1) = 2/3; (term 2) = 4/3; (term 3) = 4/5; ... (define (term n) (define numerator (+ 2.0 (- n (remainder n 2)))) (define denominator (+ 2.0 (- n (remainder (+ n 1) 2)))) (/ numerator denominator)) (* 4.0 (product term 1 inc n))) (approx-pi 10000) ; ==> 3.1417497057379635 (not a very good job at approximating now huh) Similarly, an iterative solution can be used: (define (product term a next b) (define (iter a result) (if (> a b) result (iter (next a) (* result (term a))))) (iter a 1)) (approx-pi 10000) ; ==> 3.1417497057380084 Exercise 1.32 \u00b6 (define (accumulate combiner null-value term a next b) (if (> a b) null-value (combiner (term a) (accumulate combiner null-value term (next a) next b)))) (define (sum term a next b) (accumulate + 0 term a next b)) (define (product term a next b) (accumulate * 1 term a next b)) Similarly, an iterative solution can be used: (define (accumulate combiner null-value term a next b) (define (iter a result) (if (> a b) result (iter (next a) (combiner result (term a))))) (iter a null-value)) Exercise 1.33 \u00b6 ; filtered-accumulate accumulates term(i) from a to b inclusive that satisfy filter(i) (define (filtered-accumulate combiner null-value term a next b filter) (define (iter a result) (cond ((> a b) result) ((filter a) (iter (next a) (combiner result (term a)))) (else (iter (next a) result)))) (iter a null-value)) ; sum-of-square-of-primes computes sum of square of primes from a to b inclusive (define (sum-of-square-of-primes a b) (define (square n) (* n n)) (define (inc n) (+ n 1)) (define (prime? n) (define (smallest-divisor n) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (cond ((> (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (find-divisor n 2)) (if (< n 2) #f (= n (smallest-divisor n)))) ; disclude <= 2 (filtered-accumulate + 0 square a inc b prime?)) (sum-of-square-of-primes 1 10) ; ==> 4+9+25+49 = 87 ; product-of-relative-primes returns the product of i from 1 to n where gcd(i,n) == 1 (define (product-of-relative-primes n) (define (gcd a b) (if (= b 0) a (gcd b (remainder a b)))) (define (is-relatively-prime x) (= (gcd x n) 1)) (define (identity x) x) (define (inc x) (+ x 1)) (filtered-accumulate * 1 identity 1 inc n is-relatively-prime)) (product-of-relative-primes 10) ; ==> 1*3*7*9 = 189 Exercise 1.34 \u00b6 (define (f g) (g 2)) (f square) ; ==> (square 2) = 4 (f (lambda (z) (* z (+ z 1)))) ; ==> (* 2 (+ 2 1)) = 6 (f f) ; (f 2) ; (2 2) But since 2 is not a callable function, the interpreter outputs an error. ;The object 2 is not applicable. ;To continue, call RESTART with an option number: ; (RESTART 2) => Specify a procedure to use in its place. ; (RESTART 1) => Return to read-eval-print level 1. Exercise 1.35 \u00b6 Note that the fixed point for \\(f\\left(x\\right)=1+\\frac{1}{x}\\) solves the equation \\(x=1+\\frac{1}{x}\\) , which can be rewritten to \\(x^2-x-1=0\\) . Solving the quadratic equation leads \\(x=\\frac{1\\pm\\sqrt{5}}{2}\\) . This means that \\(\\phi=\\frac{1+\\sqrt{5}}{2}\\) is a , but not the only, fixed point for the transformation. Let us then write a procedure to evaluate \\(\\phi\\) using fixed-point . (fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0) ; ==> 1.618... Exercise 1.36 \u00b6 (define (fixed-point f first-guess) (define (close-enough x y) (< (abs (- x y)) 0.00001)) ; print-approx just prints out x and a newline (define (print-approx x) (newline) (display \"Checking \") (display x)) (define (try guess) (let ((next (f guess))) (print-approx guess) (if (close-enough guess next) next (try next)))) (try first-guess)) (fixed-point (lambda (x) (/ (log 1000) (log x))) 3) ; Checking 3 ; Checking 6.287709822868153 ; Checking 3.757079790200296 ; Checking 5.218748919675315 ; Checking 4.180797746063314 ; Checking 4.828902657081293 ; Checking 4.386936895811029 ; Checking 4.671722808746095 ; Checking 4.481109436117821 ; Checking 4.605567315585735 ; Checking 4.522955348093164 ; Checking 4.577201597629606 ; Checking 4.541325786357399 ; Checking 4.564940905198754 ; Checking 4.549347961475409 ; Checking 4.5596228442307565 ; Checking 4.552843114094703 ; Checking 4.55731263660315 ; Checking 4.554364381825887 ; Checking 4.556308401465587 ; Checking 4.555026226620339 ; Checking 4.55587174038325 ; Checking 4.555314115211184 ; Checking 4.555681847896976 ; Checking 4.555439330395129 ; Checking 4.555599264136406 ; Checking 4.555493789937456 ; Checking 4.555563347820309 ; Checking 4.555517475527901 ; Checking 4.555547727376273 ; Checking 4.555527776815261 ; Checking 4.555540933824255 ; ==> 4.555532257016376 Exercise 1.37 \u00b6 ; const-frac evaluates the k-term finite continued fraction ; where n(i), d(i) are terms where i is from 1 to k. (define (const-frac n d k) (define (const-frac-iter i) (if (> i k) 0 (/ (n i) (+ (d i) (const-frac-iter (+ i 1)))))) (const-frac-iter 1)) ; silver-ratio returns the silver ratio (0.61803..) using const-frac with k iterations (define (silver-ratio k) (const-frac (lambda (i) 1.0) (lambda (i) 1.0) k)) (silver-ratio 1) ; ==> 1.0 (silver-ratio 2) ; ==> 0.5 (silver-ratio 3) ; ==> 0.6667 (silver-ratio 4) ; ==> 0.6000 (silver-ratio 5) ; ==> 0.625 (silver-ratio 10) ; ==> 0.6179775280898876 (silver-ratio 15) ; ==> 0.6180344478216819 (silver-ratio 20) ; ==> 0.6180339850173578 (silver-ratio 25) ; ==> 0.6180339887802426 (silver-ratio 50) ; ==> 0.6180339887498948 Similarly, an iterative solution can be written: (define (const-frac n d k) ; i counts BACKWARDS! (define (const-frac-iter i result) (if (= i 0) result (const-frac-iter (- i 1) (/ (n i) (+ (d i) result))))) (const-frac-iter k 0)) (silver-ratio 1) ; ==> 1.0 (silver-ratio 2) ; ==> 0.5 (silver-ratio 3) ; ==> 0.6666666666666666 (silver-ratio 4) ; ==> 0.6000000000000001 (silver-ratio 5) ; ==> 0.625 (silver-ratio 10) ; ==> 0.6179775280898876 (silver-ratio 15) ; ==> 0.6180344478216819 (silver-ratio 20) ; ==> 0.6180339850173578 (silver-ratio 25) ; ==> 0.6180339887802426 (silver-ratio 50) ; ==> 0.6180339887498948 The result becomes accurate to four decimal places by k=10 . Exercise 1.38 \u00b6 ; approx-e-less-2 computes the approximation of e-2 ; using Euler's continued fraction and const-frac. ; k is the number of iterations to be done (define (approx-e-less-2 k) (define (N i) 1.0) (define (D i) (if (= 2 (remainder i 3)) (* (/ (+ i 1) 3) 2) 1)) (const-frac N D k)) (approx-e-less-2 10) ; ==> 0.7182817182817183 Exercise 1.39 \u00b6 ; tan-cf computes the tangent of x (radians) using const-frac. ; Note that k might have to be large if x were large. (define (tan-cf x k) (define (N i) (if (= i 1) x (- (* x x)))) (define (D i) (- (* 2 i) 1.0)) (const-frac N D k)) (tan 3) ; ==> -.1425465430742778 (tan-cf 3 10) ; ==> -.1425465438397583 Exercise 1.40 \u00b6 This is trivial to implement. ; cubic represents a cubic equation x^3+ax^2+bx+c (define (cubic a b c) (lambda (x) (+ (* x x x) (* a x x) (* b x) c))) Exercise 1.41 \u00b6 This is also trivial to implement but somehow difficult to wrap around. ; double returns a wrapped function such that f -> f(f) where f : val -> val (define (double f) (lambda (x) (f (f x)))) (define (inc x) (+ x 1)) (((double (double double)) inc) 5) ; (((double (lambda (f) (double (double f)))) inc) 5) ; substitute the parent double ; (((lambda (f) (double (double (double (double f))))) inc) 5) ; ((double (double (double (double inc)))) 5) ; ((double (double (double (lambda (x) (inc (inc x)))))) 5) ; ((double (double (lambda (x) (inc (inc (inc (inc x))))))) 5) ; ((double (lambda (x) (inc (inc (inc (inc (inc (inc (inc (inc x)))))))))) 5) ; ((lambda (x) (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc x))))))))))))))))) 5) ; (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc 5)))))))))))))))) ; ==> 21 Exercise 1.42 \u00b6 (define (compose f g) (lambda (x) (f (g x)))) ((compose square inc) 6) ; ==> 49 Exercise 1.43 \u00b6 (define (repeated f n) (define (iter i) (if (= i n) (lambda (x) x) (compose f (iter (+ i 1))))) (iter 0)) ((repeated square 2) 5) ; ==> 625 As always, an iterative solution can be found: (define (repeated f n) (define (iter result i) (if (= i n) result (iter (compose f result) (+ i 1)))) (iter f 1)) ((repeated square 2) 5) ; ==> 625 Exercise 1.44 \u00b6 ; smooth returns a procedure describing a smoothed function (define (smooth f) (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)) ; smooth-n returns the n-fold smoothed function (define (smooth-n f n) (repeated smooth n)) Exercise 1.45 \u00b6 ; n-th root returns a function for the n'th root of x such that ; the fixed point of y -> x/y^(n-1) is calculated, and the transformation is done r times. (define (nth-root n r) (define (average a b) (/ (+ a b) 2.0)) (lambda (x) (define (ave-dump y) (average y (/ x (expt y (- n 1))))) (fixed-point (repeated ave-dump r) 1.0))) ((nth-root 2 1) 4) ; ==> 2.000000000000002 It does not seem to work for degree 6 or higher. Maybe I'm doing something wrong here. Exercise 1.46 \u00b6 ; iterative-improve returns a procedure which gets on improved upon while it is not yet good enough. ; good-enough? returns true if the value is indeed good enough. (val ==> false) ; improve improves upon the guess (val ==> val) (define (iterative-improve good-enough? improve) (define (rinse-and-repeat x) (if (good-enough? x) x (rinse-and-repeat (improve x)))) (lambda (x) (rinse-and-repeat x))) (define (sqrt x) (define (square x) (* x x)) (define (average x y) (/ (+ x y) 2)) (define (print-approx x) (newline) (display \"Checking \") (display x)) (define (improve guess) (average guess (/ x guess))) (define (good-enough? guess) (< (abs (- (square guess) x)) 0.001)) ; multiply by 1.0 to turn to floating-point ((iterative-improve good-enough? improve) (* x 1.0))) (sqrt 103) ; ==> 10.14889156529969 (define (fixed-point f first-guess) (define (good-enough? x) (< (abs (- x (f x))) 0.000001)) (define (improve x) (f x)) ((iterative-improve good-enough? improve) first-guess)) (fixed-point cos 1.0) ; ==> .7390845495752126 Note that, with fixed-point , computing for (f x) may need to be done twice : the first time to check if the value is good enough, and the second to improve the guess.","title":"1"},{"location":"1-building-abstractions-using-procedures/#building-abstractions-using-procedures","text":"","title":"Building Abstractions Using Procedures"},{"location":"1-building-abstractions-using-procedures/#11-the-elements-of-programming","text":"","title":"1.1 The Elements of Programming"},{"location":"1-building-abstractions-using-procedures/#exercise-11","text":"10 ; 10 (+ 5 3 4) ; 12 (- 9 1) ; 8 (/ 6 2) ; 3 (+ (* 2 4) (- 4 6)) ; 6 (define a 3) ; a = 3 (define b (+ a 1)) ; b = 4 (+ a b (* a b)) ; 19 (= a b) ; #f (if (and (> b a) (< b (* a b))) b a) ; 4 (cond ((= a 4) 6) ((= b 4) (+ 6 7 a)) (else 25)) ; (+ 6 7 a) => 16 (+ 2 (if (> b a) b a)) ; 6 (* (cond ((> a b) a) ((< a b) b) (else -1)) (+ a 1)) ; 16","title":"Exercise 1.1"},{"location":"1-building-abstractions-using-procedures/#exercise-12","text":"(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))","title":"Exercise 1.2"},{"location":"1-building-abstractions-using-procedures/#exercise-13","text":"; sum-of-squares takes in two numbers and returns the sum of their squares (define (sum-of-squares a b) (+ (* a a) (* b b))) ; exercise-1-3 takes in three numbers ; and returns the sum of squares of the two larger numbers (define (exercise-1-3 a b c) ( cond ((and (< b a) (< b c)) (sum-of-squares a c)) ((and (< a b) (< a c)) (sum-of-squares b c)) (else (sum-of-squares a b)) ) )","title":"Exercise 1.3"},{"location":"1-building-abstractions-using-procedures/#exercise-14","text":"(define (a-plus-abs-b a b) ((if (> b 0) + -) a b)) ; the operator changes depending on the value of the if statement!! ; if b>0 return a+b otherwise return a-b (which turns b positive and adds it to a)","title":"Exercise 1.4"},{"location":"1-building-abstractions-using-procedures/#exercise-15","text":"(define (p) (p)) ; a recursive function (don't execute this!!) (define (test x y) (if (= x 0) 0 y)) (test 0 (p)) ; don't run this on applicative-order systems On normal-order evaluation, the expression (test 0 (p)) first expands to (if (= 0 0) 0 (p)) , which will be evaluated to 0 . On applicative-order evaluation, the expression (test 0 (p)) will have (p) expanded to... (p) , and then expanded to (p) recursively, leading to no real work being done.","title":"Exercise 1.5"},{"location":"1-building-abstractions-using-procedures/#exercise-16","text":"Substituting this new-if function in the procedure causes a maximum recursion depth exceeded error, even for an input of 1 . Why? (sqrt 1) ; ==> (sqrt-iter 1.0 1) ; ==> (new-if (good-enough? 1.0 1) 1.0 (sqrt-iter (improve guess x) x)) Here lies the kicker. Before new-if gets substituted, it first has to evaluate the arguments (good-enough? 1.0 1) , which easily evaluates to #t , and (sqrt-iter (improve guess x) x) , which does a recursive loop. The stack continues to grow until maximum recursion depth is reached.","title":"Exercise 1.6"},{"location":"1-building-abstractions-using-procedures/#exercise-17","text":"; eval-sqrt evaluates the sqrt function for a number (define (eval-sqrt x) (- (square (sqrt x)) x)) (eval-sqrt 4.64e-35) ; ==> .0009765625, or 9.765625e-4 (eval-sqrt 104828495672) ; ==> -.0000152587890625 Notice two things here. The first one is that the evaluation of the square root of the very small number has a ridiculously large error, where it is off by several orders of magnitude. (The real value of the square root is 6.8117e-18.) This is expected since good-enough checks if the difference between the values is less than some constant threshold: good for most cases, but bad for numbers that are smaller than said threshold. The second one is that there is always some amount of error when dealing with floating point numbers, as shown in the second example. Some precision will always be lost when dealing with floats. Redefining good-enough to check relative to guess : ; good-enough checks if the difference between the current and next guess ; is less than 0.0001% of the current value of guess (define (good-enough guess x) (< (abs (- guess (improve guess x))) (/ guess 100000))) (eval-sqrt 4.64e-35) ; ==> 2.800177998007718e-41 (eval-sqrt 104828495672) ; ==> 991925.5386352539 While the value for error might seem much larger for large numbers, running (sqrt 104828495672) yields 323773.8216680568, not too far off from the real value of 323772.289846. In addition, running (sqrt 4.64e-35) yields 6.811756601771674e-18, really close to the actual value.","title":"Exercise 1.7"},{"location":"1-building-abstractions-using-procedures/#exercise-18","text":"; cbrt solves the cube root using Newton's method (define (cbrt x) (define (cbrt-iter guess x) (if (cbrt-goodenough guess x) guess (cbrt-iter (cbrt-improve guess x) x))) (define (cbrt-improve guess x) (/ (+ (/ x (* guess guess)) (* 2 guess)) 3)) (define (cbrt-goodenough guess x) (< (abs (- guess (cbrt-improve guess x))) (/ guess 100000))) (cbrt-iter 1.0 x)) (cbrt 27) ; ==> 3.0000005410641766","title":"Exercise 1.8"},{"location":"1-building-abstractions-using-procedures/#12-procedures-and-the-processes-they-generate","text":"","title":"1.2 Procedures and the Processes they Generate"},{"location":"1-building-abstractions-using-procedures/#exercise-19","text":"Supposing inc and dec are increment and decrement operators respectively, there is a difference how these two functions work: ; First process (define (+ a b) (if (= a 0) b (inc (+ (dec a) b)))) (+ 4 5) ; (inc (+ (dec 4) 5)) ; (inc (+ 3 5)) ; (inc (inc (+ (dec 3) 5))) ; (inc (inc (+ 2 5))) ; (inc (inc (inc (+ (dec 2) 5)))) ; (inc (inc (inc (+ 1 5)))) ; (inc (inc (inc (inc (+ (dec 1) 5))))) ; (inc (inc (inc (inc (+ 0 5))))) ; (inc (inc (inc (inc 5)))) ; (inc (inc (inc 6))) ; (inc (inc 7)) ; (inc 8) ; (9) ; Second process (define (+ a b) (if (= a 0) b (+ (dec a) (inc b)))) (+ 4 5) ; (+ (dec 4) (inc 5)) ; (+ 3 6) ; (+ (dec 3) (inc 6)) ; (+ 2 7) ; (+ (dec 2) (inc 7)) ; (+ 1 8) ; (+ (dec 1) (inc 8)) ; (+ 0 9) ; (9) The first process can be characterized as recursive since a chain of operations can be seen growing after every call, while the second can be characterized as iterative as the chain of operations does not grow or shrink, and the state is maintained by the parameters it contains.","title":"Exercise 1.9"},{"location":"1-building-abstractions-using-procedures/#exercise-110","text":"Consider Ackermann's function: (define (A x y) (cond ((= y 0) 0) ((= x 0) (* 2 y)) ((= y 1) 2) (else (A (- x 1) (A x (- y 1)))))) From here, we see that f such that (define (f n) (A 0 n)) would just be \\(f\\left(n\\right)=2n\\) . (A 1 10) ; (A (- 1 1) (A 1 (- 10 1))) ; (A 0 (A 1 9)) ; (A 0 (A (- 1 1) (A 1 (- 9 1)))) ; (A 0 (A 0 (A 1 8))) ; (A 0 (A 0 (A (- 1 1) (A 1 (- 8 1))))) ; (A 0 (A 0 (A 0 (A 1 7)))) ; (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 7 1)))))) ; (A 0 (A 0 (A 0 (A 0 (A 1 6))))) ; (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 6 1))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5)))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 5 1)))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 4 1))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3)))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 3 1)))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A (- 1 1) (A 1 (- 2 1))))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1)))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 2))))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4)))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 4)))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 8))))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16)))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 16)))))) ; (A 0 (A 0 (A 0 (A 0 (A 0 32))))) ; (A 0 (A 0 (A 0 (A 0 (* 2 32))))) ; (A 0 (A 0 (A 0 (A 0 64)))) ; (A 0 (A 0 (A 0 (* 2 64)))) ; (A 0 (A 0 (A 0 128))) ; (A 0 (A 0 (* 2 128))) ; (A 0 (A 0 256)) ; (A 0 (* 2 256)) ; (A 0 512) ; (* 2 0 512) ; (1024) Hypothesize that g such that (define (g n) (A 1 n)) equals \\(g\\left(n\\right)=2^n\\) . This can be proved using induction: suppose \\(A\\left(1,n\\right)=2^n\\) , and prove that \\(A\\left(1,n+1\\right)=2^{n+1}\\) . \\[ \\begin{aligned} A\\left(1,n+1\\right) &= A\\left(1-1, A\\left(1, \\left(n+1\\right)-1\\right)\\right) \\\\ &= A\\left(0, A\\left(1, n\\right)\\right) \\\\ &= 2\\cdot A\\left(1,n\\right) \\\\ &= 2\\cdot2^n \\\\ &= 2^{n+1} \\end{aligned} \\] (A 2 4) ; (A (- 2 1) (A 2 (- 4 1))) ; (A 1 (A 2 3)) ; (A 1 (A (- 2 1) (A 2 (- 3 1)))) ; (A 1 (A 1 (A 2 2))) ; (A 1 (A 1 (A (- 2 1) (A 2 (- 2 1))))) ; (A 1 (A 1 (A 1 (A 2 1)))) ; (A 1 (A 1 (A 1 2))) From our previous definition of g , we can say that the expression (A 1 (A 1 (A 1 2))) solves to \\(2^{2^{2^2}}\\) , although writing down the steps to getting there will be hell an exercise left to the reader. Hypothesize that h such that (define (h n) (A 2 n)) equals \\(h\\left(n\\right)=2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}}\\) , such that the number of \\(2\\) equals \\(n\\) . This also can be proved using induction: suppose \\(A\\left(2,n\\right)=2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}} \\rbrace\\text{n-many 2's}\\) , and prove that \\(A\\left(2,n+1\\right)\\) results to \\(n+1\\) twos: \\[ \\begin{aligned} A\\left(2,n+1\\right) &= A\\left(2-1, A\\left(2, \\left(n+1\\right)-1\\right)\\right) \\\\ &= A\\left(1,A\\left(2,n\\right)\\right) \\\\ % why do i even bother... &= A\\left(1, \\left.2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}}\\right\\rbrace\\text{$n$-many 2's}\\right) \\\\ &= 2^{\\left.2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}}\\right\\rbrace\\text{$n$-many 2's}} \\\\ &= \\left.2^{2^{\\cdot^{\\cdot^{\\cdot^2}}}}\\right\\rbrace\\text{$n+1$-many 2's} \\end{aligned} \\]","title":"Exercise 1.10"},{"location":"1-building-abstractions-using-procedures/#exercise-111","text":"Writing the recursive implementation is trivial: (define (f n) (if (< n 3) n (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3)))))) (f 30) ; ==> 61354575194 (will take a long time to compute) Writing an iterative implementation is a bit more difficult. Consider that, ultimately, f is evaluated as a sum of three numbers, and these three numbers can be used as a state. (define (f n) ; iter is the iterative process wherein (a, b, c) <- (a+2b+3c, a, b). ; if count == 0, return a (define (iter a b c count) (if (= count 0) a (iter (+ a (* 2 b) (* 3 c)) a b (- count 1)))) (if (< n 3) n (iter 2 1 0 (- n 2))) ; 2 as an offset ) (f 30) ; ==> 61354575194 (didn't take that long at all!)","title":"Exercise 1.11"},{"location":"1-building-abstractions-using-procedures/#exercise-112","text":"; pascal returns the cnt'th number (start from zero) ; at the row'th row (0: 1, 1: 1,1, 2: 1,2,1). (define (pascal row cnt) (cond ((or (< cnt 0) (> cnt row)) 0) ((or (= cnt 0) (= cnt row)) 1) (else (+ (pascal (- row 1) (- cnt 1)) (pascal (- row 1) cnt)) ) ) ) (pascal 4 2)","title":"Exercise 1.12"},{"location":"1-building-abstractions-using-procedures/#exercise-113","text":"Initially, let us prove that \\(F\\left(n\\right) = \\frac{\\phi^n - \\psi^n}{\\sqrt{5}}\\) , where \\(F\\left(n\\right)\\) is the \\(n\\) 'th Fibonacci number and \\(\\phi=\\frac{1+\\sqrt{5}}{2}, \\psi=\\frac{1-\\sqrt{5}}{2}\\) , via induction. The base cases for \\(F\\left(0\\right)\\) and \\(F\\left(1\\right)\\) is shown to be 0 and 1. A proof is left as an exercise to the reader. Suppose that \\(F\\) follows up to \\(n-1\\) . Let us then prove that \\(F\\left(n\\right)\\) holds. \\[ \\begin{aligned} F\\left(n\\right) &= F\\left(n-1\\right) + F\\left(n-2\\right) \\\\ &= \\frac{\\phi^\\left(n-1\\right) - \\psi^\\left(n-1\\right)}{\\sqrt{5}} + \\frac{\\phi^\\left(n-2\\right) - \\psi^\\left(n-2\\right)}{\\sqrt{5}} \\\\ &= \\frac{\\left(\\phi+1\\right) \\phi^\\left(n-2\\right) - \\left(\\psi+1\\right) \\psi^\\left(n-2\\right)}{\\sqrt{5}} \\\\ &= \\frac{\\frac{3+\\sqrt{5}}{2} \\phi^\\left(n-2\\right) - \\frac{3-\\sqrt{5}}{2} \\psi^\\left(n-2\\right)}{\\sqrt{5}} && \\text{Note that $\\frac{3\\pm\\sqrt{5}}{2}=\\left(\\frac{1\\pm\\sqrt{5}}{2}\\right)^2$} \\\\ &= \\frac{\\phi^2 \\phi^\\left(n-2\\right) - \\psi^2 \\psi^\\left(n-2\\right)}{\\sqrt{5}} \\\\ &= \\frac{\\phi^n - \\psi^n}{\\sqrt{5}} \\end{aligned} \\] Note that \\(\\psi\\approx-0.618\\) and \\(\\psi^n\\) approaches zero. Therefore, \\(\\frac{\\phi^n}{\\sqrt{5}}\\) is \"close enough\" to \\(\\frac{\\phi^n - \\psi^n}{\\sqrt{5}}\\) .","title":"Exercise 1.13"},{"location":"1-building-abstractions-using-procedures/#exercise-114","text":"Paths leading to a red node are unwanted, whereas paths leading to a green node are desired. Note that multiple sections of the tree repeat itself, which is why a node can have more than two paths coming towards it. An increment to amount increases the number of operations exponentially, and increases the number of nodes to compute linearly.","title":"Exercise 1.14"},{"location":"1-building-abstractions-using-procedures/#exercise-115","text":"(define (cube x) (* x x x)) (define (p x) (- (* 3 x) (* 4 (cube x)))) (define (sine angle) (if (not (> (abs angle) 0.1)) angle (p (sine (/ angle 3.0))))) (sine 12.15) ; (/ angle 3.0) and (p x) operations have been substituted ; (p (sine 4.05)) ; (p (p (sine 1.35))) ; (p (p (p (sine 0.45)))) ; (p (p (p (p (sine 0.15))))) ; (p (p (p (p (p (sine 0.05)))))) ; (p (p (p (p (p 0.05))))) ; (p (p (p (p 0.1495)))) ; (p (p (p 0.4351))) ; (p (p 0.9758)) ; (p -0.7892) ; -0.4044 The p procedure has been applied five times. Considering that p can be solved in constant time and occupies constant space, the order of growth in space and the number of steps for \\(p\\left(a\\right)\\) is \\(\\Theta\\left(\\lg n\\right)\\) . This can be shown by noticing that \\(p\\left(3a\\right)\\) requires a constant number of operations more than \\(p\\left(a\\right)\\) , for instance, the amount of space and operations for (sine 1.35) versus that of (sine 4.05) .","title":"Exercise 1.15"},{"location":"1-building-abstractions-using-procedures/#exercise-116","text":"; expt is an exponential function that returns b raised to n. ; note that this shadows the built-in expt. (define (expt b n) (define (even? n) (= (remainder n 2) 0)) (define (halve n) (/ n 2)) (define (square n) (* n n)) ; exptiter iterates thru a, b, and n until b equals 1, and then the result is located in a. ; a must be initialized to 1. (define (exptiter a b n) (cond ((= n 0) a) ((even? n) (exptiter a (square b) (halve n))) (else (exptiter (* a b) b (- n 1))))) (exptiter 1 b n)) (expt 3 5) ; ==> 243","title":"Exercise 1.16"},{"location":"1-building-abstractions-using-procedures/#exercise-117","text":"(define (mul a b) (define (even? n) (= (remainder n 2) 0)) (define (halve n) (/ n 2)) (define (double n) (+ n n)) (cond ((= b 0) 0) ((= b 1) a) ((even? b) (mul (double a) (halve b))) (else (+ a (mul a (- b 1)))))) (mul 9 6) ; ==> 54","title":"Exercise 1.17"},{"location":"1-building-abstractions-using-procedures/#exercise-118","text":"(define (mul a b) (define (even? n) (= (remainder n 2) 0)) (define (halve n) (/ n 2)) (define (double n) (+ n n)) (define (multiter a b result) (cond ((= b 0) result) ((even? b) (multiter (double a) (halve b) result)) (else (multiter a (- b 1) (+ result a))))) (multiter a b 0)) (mul 9 6) ; ==> 54","title":"Exercise 1.18"},{"location":"1-building-abstractions-using-procedures/#exercise-119","text":"Note that \\(a, b \\xleftarrow{T\\left(p,q\\right)} bq+aq+ap, bp+aq = a\\left(p+q\\right)+bq, aq+bp\\) . With some algebra, \\[ \\begin{aligned} a, b &\\xleftarrow{T^2\\left(p,q\\right)} \\left(ap^2+2apq+2bpq+2aq^2+bq^2\\right), \\left(bp^2+2apq+aq^2+bq^2\\right) \\\\ &\\xleftarrow{T^2\\left(p,q\\right)} a\\left(p^2+2pq+2q^2\\right)+b\\left(2pq+q^2\\right), a\\left(2pq+q^2\\right)+b\\left(p^2+q^2\\right) \\\\ T^2\\left(p,q\\right) &= T\\left(p^2+q^2, 2pq+q^2\\right) \\end{aligned} \\] (define (fib n) (define (even? n) (= (remainder n 2) 0)) (define (fib-iter a b p q count) (cond ((= count 0) b) ((even? count) (fib-iter a b (+ (* p p) (* q q)) (+ (* 2 p q) (* q q)) (/ count 2))) (else (fib-iter (+ (* b p) (* a q) (* a p)) (+ (* b p) (* a q)) p q (- count 1))))) (fib-iter 1 0 0 1 n)) (fib 35) ; ==> 9227465","title":"Exercise 1.19"},{"location":"1-building-abstractions-using-procedures/#exercise-120","text":"(define (gcd a b) (if (= b 0) a (gcd b (remainder a b)))) (gcd 206 40) ; for normal-order evaluation (18 remainder operations) ; (gcd 206 40) ; (if (= 40 0) 206 (gcd 40 (remainder 206 40))) ; (gcd 40 (remainder 206 40)) ; (if (= (remainder 206 40) 0) 40 (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (if (= 6 0) ; remainder +1 ; 40 ; (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (gcd (remainder 206 40) (remainder 40 (remainder 206 40))) ; (if (= (remainder 40 (remainder 206 40)) 0) ; (remainder 206 40) ; (gcd ; (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; (if (= 4 0) ; remainder +2 ; (remainder 206 40) ; (gcd ; (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; (gcd ; (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (if (= (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) 0) ; (remainder 40 (remainder 206 40)) ; (gcd ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))) ; (if (= 2 0) ; remainder +4 ; (remainder 40 (remainder 206 40)) ; (gcd ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))) ; (gcd ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; (if (= (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) 0) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (gcd ; (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))) ; (if (= 0 0) ; remainder +7 ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; (gcd ; (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; (remainder (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))))) ; (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) ; ==> 2 ; remainder +4 ; for applicative-order evaluation (4 remainder operations) ; (gcd 206 40) ; (if (= 40 0) 206 (gcd 40 (remainder 206 40))) ; (gcd 40 6) ; remainder +1 ; (if (= 6 0) 40 (gcd 6 (remainder 40 6))) ; (gcd 6 4) ; remainder +1 ; (if (= 4 0) 6 (gcd 4 (remainder 6 4))) ; (gcd 4 2) ; remainder +1 ; (if (= 2 0) 4 (gcd 2 (remainder 4 2))) ; (gcd 2 0) ; remainder +1 ; (if (= 0 0) 2 (gcd 2 (remainder 0 0))) ; ==> 2","title":"Exercise 1.20"},{"location":"1-building-abstractions-using-procedures/#exercise-121","text":"(define (smallest-divisor n) (define (divides? a b) (= (remainder b a) 0)) (define (square n) (* n n)) (define (find-divisor n test-divisor) (cond ((> (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (find-divisor n 2)) (smallest-divisor 199) ; (find-divisor 199 2) ; (find-divisor 199 3) ; ... ; (find-divisor 199 15) ; ==> 199 A similar event happens for 1999 where find-diivisor exhausts test-divisor from 2 to 45, and since the square of 45 is larger than 1999, it gives up and returns 1999. For 19999, when test-divisor becomes 7, (divides? 7 19999) returns #t and the iterative process stops and returns 7.","title":"Exercise 1.21"},{"location":"1-building-abstractions-using-procedures/#exercise-122","text":"Because computing for primes larger than a million seems to be nearly instantaneous in modern hardware, I decided to increase their values by several orders of magnitude. ; search-for-primes prints out `count` number of primes from (including) `from`. ; If `count` <= 0 terminate the search. ; If from <= 1 set from to 2 (define (search-for-primes from count) (define (even? n) (= (remainder n 2) 0)) ; prime? checks for primality (define (prime? n) (define (smallest-divisor n) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (cond ((> (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (find-divisor n 2)) (= n (smallest-divisor n))) ; timed-prime? prints a message and returns true if n is prime; returns false otherwise (define (timed-prime? n) (define (start-prime-test n start-time) (if (prime? n) (report-prime (- (runtime) start-time)) #f)) (define (report-prime elapsed-time) (newline) (display n) (display \" is a prime\") (display \" *** \") (display elapsed-time) #t) (start-prime-test n (runtime))) (define (search-for-primes-iter n c) (cond ((= c 0) 0) ((timed-prime? n) (search-for-primes-iter (+ n 2) (- c 1))) (else (search-for-primes-iter (+ n 2) c)))) (cond ((<= count 0) 0) ((<= from 2) (search-for-primes-iter 3 (- count 1))) ((even? from) (search-for-primes-iter (+ from 1) count)) (else (search-for-primes-iter from count)))) ; increase by sqrt(10) per iteration (search-for-primes 1000000000 3) ; 1000000007 is a prime *** .06 ; 1000000009 is a prime *** .07 ; 1000000021 is a prime *** .06 (search-for-primes 3162280000 3) ; 3162280001 is a prime *** .07999999999999996 ; 3162280049 is a prime *** .07000000000000006 ; 3162280063 is a prime *** .07999999999999996 (search-for-primes 10000000000 3) ; 10000000019 is a prime *** .1100000000000001 ; 10000000033 is a prime *** .14 ; 10000000061 is a prime *** .1299999999999999 (search-for-primes 31622800000 3) ; 31622800021 is a prime *** .21999999999999997 ; 31622800031 is a prime *** .21999999999999997 ; 31622800037 is a prime *** .2100000000000002 (search-for-primes 100000000000 3) ; 100000000003 is a prime *** .3999999999999997 ; 100000000019 is a prime *** .3799999999999999 ; 100000000057 is a prime *** .36999999999999966 (search-for-primes 316228000000 3) ; 316228000021 is a prime *** .6600000000000001 ; 316228000051 is a prime *** .6699999999999999 ; 316228000057 is a prime *** .6699999999999999 (search-for-primes 1000000000000 3) ; 1000000000039 is a prime *** 1.17 ; 1000000000061 is a prime *** 1.17 ; 1000000000063 is a prime *** 1.1900000000000004 (search-for-primes 3162280000000 3) ; 3162280000021 is a prime *** 2.1000000000000014 ; 3162280000043 is a prime *** 2.41 ; 3162280000109 is a prime *** 2.25 (search-for-primes 10000000000000 3) ; 10000000000037 is a prime *** 3.759999999999998 ; 10000000000051 is a prime *** 3.75 ; 10000000000099 is a prime *** 3.7600000000000016 Notice that when the numbers incrases by two orders of magnitude (every four iterations), the time it takes increases by one order of magnitude. That is, \\(T\\left(100n\\right) \\approx 10T\\left(n\\right)\\) This satisfies \\(\\Theta\\left(T\\left(n\\right)\\right) = \\Theta\\left(\\sqrt{n}\\right)\\) .","title":"Exercise 1.22"},{"location":"1-building-abstractions-using-procedures/#exercise-123","text":"The prime? function in the above code is replaced with as follows: (define (search-for-primes from count) ; ... code above goes here ; prime? checks for primality (define (prime? n) (define (smallest-divisor n) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (define (next divisor) (if (= divisor 2) 3 (+ divisor 2))) (cond ((> (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (next test-divisor))))) (find-divisor n 2)) (= n (smallest-divisor n))) ; ... code below goes here ) (search-for-primes 1000000000 3) ; 1000000007 is a prime *** 3.0000000000000027e-2 ; 1000000009 is a prime *** .03999999999999998 ; 1000000021 is a prime *** .02999999999999997 (search-for-primes 3162280000 3) ; 3162280001 is a prime *** 5.0000000000000044e-2 ; 3162280049 is a prime *** .06 ; 3162280063 is a prime *** 5.0000000000000044e-2 (search-for-primes 10000000000 3) ; 10000000019 is a prime *** .10000000000000009 ; 10000000033 is a prime *** .08999999999999997 ; 10000000061 is a prime *** .09999999999999998 (search-for-primes 31622800000 3) ; 31622800021 is a prime *** .15000000000000002 ; 31622800031 is a prime *** .16999999999999993 ; 31622800037 is a prime *** .21999999999999997 (search-for-primes 100000000000 3) ; 100000000003 is a prime *** .28 ; 100000000019 is a prime *** .28 ; 100000000057 is a prime *** .2599999999999998 (search-for-primes 316228000000 3) ; 316228000021 is a prime *** .46999999999999975 ; 316228000051 is a prime *** .45999999999999996 ; 316228000057 is a prime *** .46999999999999975 (search-for-primes 1000000000000 3) ; 1000000000039 is a prime *** .81 ; 1000000000061 is a prime *** .8399999999999999 ; 1000000000063 is a prime *** .8399999999999999 (search-for-primes 3162280000000 3) ; 3162280000021 is a prime *** 1.490000000000001 ; 3162280000043 is a prime *** 1.5500000000000007 ; 3162280000109 is a prime *** 1.4700000000000006 (search-for-primes 10000000000000 3) ; 10000000000037 is a prime *** 2.7299999999999986 ; 10000000000051 is a prime *** 2.6799999999999997 ; 10000000000099 is a prime *** 3.0100000000000016 Using linear regression, we can say that the time it takes for primes to be evaluated is roughly 73% of the original time. Removing even numbers as candidate divisors reduced the amount of time to compute by 27%. This is different from the 50% reduction that would have been expected by removing 50% of the candidate divisors. This is perhaps attributed to the time it takes for next to be evaluated, and the if function inside it.","title":"Exercise 1.23"},{"location":"1-building-abstractions-using-procedures/#exercise-124","text":"(define (search-for-primes from count) ; ... code above goes here ; fast-prime? checks for primality using Fermat's little theorem (define (fast-prime? n times) (define (fermat-test n) (define (try-it a) (= (expmod a n n) a)) (try-it (+ 1 (random (- n 1))))) (cond ((= times 0) true) ((fermat-test n) (fast-prime? n (- times 1))) (else false))) ; timed-prime? prints a message and returns true if n is prime according to fast-prime; returns false otherwise (define (timed-prime? n) (define (start-prime-test n start-time) (if (fast-prime? n 100) (report-prime (- (runtime) start-time)) #f)) (define (report-prime elapsed-time) (newline) (display n) (display \" is a prime\") (display \" *** \") (display elapsed-time) #t) (start-prime-test n (runtime))) ; ... code below goes here ) ; incrase by sqrt(10) per iteration (search-for-primes 1000000000 3) ; 1000000007 is a prime *** 1.0000000000000009e-2 ; 1000000009 is a prime *** 1.0000000000000009e-2 ; 1000000021 is a prime *** 1.0000000000000009e-2 (search-for-primes 3162280000 3) ; 3162280001 is a prime *** 9.999999999999953e-3 ; 3162280049 is a prime *** 1.0000000000000009e-2 ; 3162280063 is a prime *** 1.0000000000000009e-2 (search-for-primes 10000000000 3) ; 10000000019 is a prime *** 1.0000000000000009e-2 ; 10000000033 is a prime *** 1.9999999999999962e-2 ; 10000000061 is a prime *** 2.0000000000000018e-2 (search-for-primes 31622800000 3) ; 31622800021 is a prime *** 2.0000000000000018e-2 ; 31622800031 is a prime *** 1.0000000000000009e-2 ; 31622800037 is a prime *** 1.9999999999999962e-2 (search-for-primes 100000000000 3) ; 100000000003 is a prime *** 1.0000000000000009e-2 ; 100000000019 is a prime *** 1.0000000000000009e-2 ; 100000000057 is a prime *** 1.0000000000000009e-2 (search-for-primes 316228000000 3) ; 316228000021 is a prime *** 1.9999999999999962e-2 ; 316228000051 is a prime *** 1.0000000000000009e-2 ; 316228000057 is a prime *** 2.0000000000000018e-2 (search-for-primes 1000000000000 3) ; 1000000000039 is a prime *** 0. ; 1000000000061 is a prime *** 1.0000000000000009e-2 ; 1000000000063 is a prime *** 1.0000000000000009e-2 (search-for-primes 3162280000000 3) ; 3162280000021 is a prime *** 1.9999999999999907e-2 ; 3162280000043 is a prime *** 1.0000000000000009e-2 ; 3162280000109 is a prime *** 3.0000000000000027e-2 (search-for-primes 10000000000000 3) ; 10000000000037 is a prime *** 1.0000000000000009e-2 ; 10000000000051 is a prime *** 2.0000000000000018e-2 ; 10000000000099 is a prime *** 1.0000000000000009e-2 Computing for prime numbers feels nearly instantaneous. Much, much larger numbers may need to be used here. (search-for-primes 1000000000000000000000000000 3) ; 1000000000000000000000000103 is a prime *** .02999999999999997 ; 1000000000000000000000000279 is a prime *** 1.9999999999999962e-2 ; 1000000000000000000000000283 is a prime *** 3.0000000000000027e-2 (search-for-primes 1000000000000000000000000000000000000000000000000000000 3) ; 1000000000000000000000000000000000000000000000000000031 is a prime *** .07999999999999996 ; 1000000000000000000000000000000000000000000000000000157 is a prime *** 5.0000000000000044e-2 ; 1000000000000000000000000000000000000000000000000000169 is a prime *** .07000000000000006 (search-for-primes 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 3) ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000019 is a prime *** .16999999999999993 ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001141 is a prime *** .1399999999999999 ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001207 is a prime *** .1399999999999999 (search-for-primes 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 3) ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000499 is a prime *** .43999999999999995 ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001107 is a prime *** .4500000000000002 ; 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001591 is a prime *** .4500000000000002 After each iteration the base is squared, leading to a near tripling of checking time: \\(T\\left(n^2\\right) \\approx 3T\\left(n\\right)\\) . This satisfies \\(\\Theta\\left(T\\left(n\\right)\\right)=\\Theta\\left(\\log n\\right)\\) .","title":"Exercise 1.24"},{"location":"1-building-abstractions-using-procedures/#exercise-125","text":"The original procedure is as follows: (define (expmod base exp m) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)))) and the modified is as follows: (define (expmod base exp m) (remainder (fast-expt base exp) m)) The issue here is that (fast-expt ...) has to be evaluated first, and base and exp can be ridiculously high. After all of that, its remainder when divided by m is computed, and all that computational power might have been wasted. The original keeps the working value no more than m , and this is indicated by the remainder operation after every step.","title":"Exercise 1.25"},{"location":"1-building-abstractions-using-procedures/#exercise-126","text":"\"...you have transformed the \\(\\Theta\\left(\\log n\\right)\\) process into a \\(\\Theta\\left(n\\right)\\) process.\" Consider first why the square procedure is being used. This is to avoid computing the value twice, as (expmod base (/ exp 2) m) would have already been evaluated and stored somewhere, and what is left to be done is to multiply its value by itself. By using (* (expmod base (/ exp 2) m) (expmod base (/ exp 2) m)) , computation would be done twice every recursive call. By doubling exp , the number of calls it takes to compute will then double, compared to just increasing by one if square were used. This can be proven using induction. Suppose that expmod takes \\(T\\left(n\\right)\\) time to compute where \\(n\\) is our exp . If we double exp , the time it takes for the (remainder (* ...)) code to run will be \\(2T\\left(n\\right)\\) , since each expmod call takes \\(T\\left(n\\right)\\) . Because of this linear relationship, \\(\\Theta\\left(T\\left(n\\right)\\right)=\\Theta\\left(n\\right)\\)","title":"Exercise 1.26"},{"location":"1-building-abstractions-using-procedures/#exercise-127","text":"(define (test-camichael n) (define (expmod base exp m) (define (even? n) (= (remainder n 2) 0)) (define (square x) (* x x)) (cond ((= exp 0) 1) ((even? exp) (remainder (square (expmod base (/ exp 2) m)) m)) (else (remainder (* base (expmod base (- exp 1) m)) m)))) ; test-camichael-recursive tests for every a < n. Once `a` reaches `n` return true. (define (test-camichael-recursive a n) (cond ((= a n) #t) ((not (= (expmod a n n) a)) #f) (else (test-camichael-recursive (+ a 1) n)))) (test-camichael-recursive 2 n)) (test-camichael 561) ; ==> #t (test-camichael 1105) ; ==> #t (test-camichael 1729) ; ==> #t (test-camichael 2465) ; ==> #t (test-camichael 2821) ; ==> #t (test-camichael 6601) ; ==> #t","title":"Exercise 1.27"},{"location":"1-building-abstractions-using-procedures/#exercise-128","text":"; miller-rabin checks if n is prime (define (miller-rabin n) ; expmod is special. ; It returns 0 if it detects a \"nontrivial square root of 1 mod n\" (define (expmod base exp m) (define (special-case n) ; if-nsr-then-zero checks if n is a non-trivial square root of 1 mod m and returns zero if so (define (if-nsr-then-zero n sq) (define (neq a b) (not (= a b))) (if (and (neq n 1) (neq n (- m 1)) (= sq 1)) 0 sq)) (if-nsr-then-zero n (remainder (square n) m))) (define (even? n) (= (remainder n 2) 0)) (define (square n) (* n n)) (cond ((= exp 0) 1) ((even? exp) (special-case (expmod base (/ exp 2) m))) (else (remainder (* base (expmod base (- exp 1) m)) m)))) (define (test n) (define (try-it a) (= (expmod a (- n 1) n) 1)) (try-it (+ 1 (random (- n 1))))) (define (test-times times) (cond ((= times 0) #t) ((test n) (test-times (- times 1))) (else #f))) (test-times 3)) ; non-primes (miller-rabin 2821) ; ==> #f (miller-rabin 1105) ; ==> #f (miller-rabin 1729) ; ==> #f (miller-rabin 2465) ; ==> #f (miller-rabin 2821) ; ==> #f (miller-rabin 6601) ; ==> #f ; primes (miller-rabin 3162280000021) ; ==> #t (miller-rabin 3162280000043) ; ==> #t (miller-rabin 3162280000109) ; ==> #t","title":"Exercise 1.28"},{"location":"1-building-abstractions-using-procedures/#13-formulating-abstractions-with-higher-order-procedures","text":"","title":"1.3 Formulating Abstractions with Higher-Order Procedures"},{"location":"1-building-abstractions-using-procedures/#exercise-129","text":"; simpson performs a Simpson's Rule integration of f from a to b. ; n denotes accuracy (and is implicitly turned even) (define (simpson f a b n) (define m (if (= 1 (remainder n 2)) (+ n 1) n)) ; \"new n\" (define h (/ (- b a) n)) ; we'll turn it into a floating-point later (define (y k) (f (+ a (* k h)))) (define (add-two x) (+ x 2)) (* (/ h 3.0) (+ (y 0) (y n) (* 4 (sum y 1 add-two (- m 1))) (* 2 (sum y 2 add-two (- m 2)))))) (simpson cube 0 1 1000) ; ==> 0.25","title":"Exercise 1.29"},{"location":"1-building-abstractions-using-procedures/#exercise-130","text":"(define (sum term a next b) (define (iter a result) (if (> a b) result (iter (next a) (+ result (term a))))) (iter a 0))","title":"Exercise 1.30"},{"location":"1-building-abstractions-using-procedures/#exercise-131","text":"(define (product term a next b) (if (> a b) 1 (* (term a) (product term (next a) next b)))) ; approx-pi evaluates pi to some accuracy level n (define (approx-pi n) (define (inc n) (+ n 1)) ; term n is as follows: (term 1) = 2/3; (term 2) = 4/3; (term 3) = 4/5; ... (define (term n) (define numerator (+ 2.0 (- n (remainder n 2)))) (define denominator (+ 2.0 (- n (remainder (+ n 1) 2)))) (/ numerator denominator)) (* 4.0 (product term 1 inc n))) (approx-pi 10000) ; ==> 3.1417497057379635 (not a very good job at approximating now huh) Similarly, an iterative solution can be used: (define (product term a next b) (define (iter a result) (if (> a b) result (iter (next a) (* result (term a))))) (iter a 1)) (approx-pi 10000) ; ==> 3.1417497057380084","title":"Exercise 1.31"},{"location":"1-building-abstractions-using-procedures/#exercise-132","text":"(define (accumulate combiner null-value term a next b) (if (> a b) null-value (combiner (term a) (accumulate combiner null-value term (next a) next b)))) (define (sum term a next b) (accumulate + 0 term a next b)) (define (product term a next b) (accumulate * 1 term a next b)) Similarly, an iterative solution can be used: (define (accumulate combiner null-value term a next b) (define (iter a result) (if (> a b) result (iter (next a) (combiner result (term a))))) (iter a null-value))","title":"Exercise 1.32"},{"location":"1-building-abstractions-using-procedures/#exercise-133","text":"; filtered-accumulate accumulates term(i) from a to b inclusive that satisfy filter(i) (define (filtered-accumulate combiner null-value term a next b filter) (define (iter a result) (cond ((> a b) result) ((filter a) (iter (next a) (combiner result (term a)))) (else (iter (next a) result)))) (iter a null-value)) ; sum-of-square-of-primes computes sum of square of primes from a to b inclusive (define (sum-of-square-of-primes a b) (define (square n) (* n n)) (define (inc n) (+ n 1)) (define (prime? n) (define (smallest-divisor n) (define (divides? a b) (= (remainder b a) 0)) (define (find-divisor n test-divisor) (cond ((> (square test-divisor) n) n) ((divides? test-divisor n) test-divisor) (else (find-divisor n (+ test-divisor 1))))) (find-divisor n 2)) (if (< n 2) #f (= n (smallest-divisor n)))) ; disclude <= 2 (filtered-accumulate + 0 square a inc b prime?)) (sum-of-square-of-primes 1 10) ; ==> 4+9+25+49 = 87 ; product-of-relative-primes returns the product of i from 1 to n where gcd(i,n) == 1 (define (product-of-relative-primes n) (define (gcd a b) (if (= b 0) a (gcd b (remainder a b)))) (define (is-relatively-prime x) (= (gcd x n) 1)) (define (identity x) x) (define (inc x) (+ x 1)) (filtered-accumulate * 1 identity 1 inc n is-relatively-prime)) (product-of-relative-primes 10) ; ==> 1*3*7*9 = 189","title":"Exercise 1.33"},{"location":"1-building-abstractions-using-procedures/#exercise-134","text":"(define (f g) (g 2)) (f square) ; ==> (square 2) = 4 (f (lambda (z) (* z (+ z 1)))) ; ==> (* 2 (+ 2 1)) = 6 (f f) ; (f 2) ; (2 2) But since 2 is not a callable function, the interpreter outputs an error. ;The object 2 is not applicable. ;To continue, call RESTART with an option number: ; (RESTART 2) => Specify a procedure to use in its place. ; (RESTART 1) => Return to read-eval-print level 1.","title":"Exercise 1.34"},{"location":"1-building-abstractions-using-procedures/#exercise-135","text":"Note that the fixed point for \\(f\\left(x\\right)=1+\\frac{1}{x}\\) solves the equation \\(x=1+\\frac{1}{x}\\) , which can be rewritten to \\(x^2-x-1=0\\) . Solving the quadratic equation leads \\(x=\\frac{1\\pm\\sqrt{5}}{2}\\) . This means that \\(\\phi=\\frac{1+\\sqrt{5}}{2}\\) is a , but not the only, fixed point for the transformation. Let us then write a procedure to evaluate \\(\\phi\\) using fixed-point . (fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0) ; ==> 1.618...","title":"Exercise 1.35"},{"location":"1-building-abstractions-using-procedures/#exercise-136","text":"(define (fixed-point f first-guess) (define (close-enough x y) (< (abs (- x y)) 0.00001)) ; print-approx just prints out x and a newline (define (print-approx x) (newline) (display \"Checking \") (display x)) (define (try guess) (let ((next (f guess))) (print-approx guess) (if (close-enough guess next) next (try next)))) (try first-guess)) (fixed-point (lambda (x) (/ (log 1000) (log x))) 3) ; Checking 3 ; Checking 6.287709822868153 ; Checking 3.757079790200296 ; Checking 5.218748919675315 ; Checking 4.180797746063314 ; Checking 4.828902657081293 ; Checking 4.386936895811029 ; Checking 4.671722808746095 ; Checking 4.481109436117821 ; Checking 4.605567315585735 ; Checking 4.522955348093164 ; Checking 4.577201597629606 ; Checking 4.541325786357399 ; Checking 4.564940905198754 ; Checking 4.549347961475409 ; Checking 4.5596228442307565 ; Checking 4.552843114094703 ; Checking 4.55731263660315 ; Checking 4.554364381825887 ; Checking 4.556308401465587 ; Checking 4.555026226620339 ; Checking 4.55587174038325 ; Checking 4.555314115211184 ; Checking 4.555681847896976 ; Checking 4.555439330395129 ; Checking 4.555599264136406 ; Checking 4.555493789937456 ; Checking 4.555563347820309 ; Checking 4.555517475527901 ; Checking 4.555547727376273 ; Checking 4.555527776815261 ; Checking 4.555540933824255 ; ==> 4.555532257016376","title":"Exercise 1.36"},{"location":"1-building-abstractions-using-procedures/#exercise-137","text":"; const-frac evaluates the k-term finite continued fraction ; where n(i), d(i) are terms where i is from 1 to k. (define (const-frac n d k) (define (const-frac-iter i) (if (> i k) 0 (/ (n i) (+ (d i) (const-frac-iter (+ i 1)))))) (const-frac-iter 1)) ; silver-ratio returns the silver ratio (0.61803..) using const-frac with k iterations (define (silver-ratio k) (const-frac (lambda (i) 1.0) (lambda (i) 1.0) k)) (silver-ratio 1) ; ==> 1.0 (silver-ratio 2) ; ==> 0.5 (silver-ratio 3) ; ==> 0.6667 (silver-ratio 4) ; ==> 0.6000 (silver-ratio 5) ; ==> 0.625 (silver-ratio 10) ; ==> 0.6179775280898876 (silver-ratio 15) ; ==> 0.6180344478216819 (silver-ratio 20) ; ==> 0.6180339850173578 (silver-ratio 25) ; ==> 0.6180339887802426 (silver-ratio 50) ; ==> 0.6180339887498948 Similarly, an iterative solution can be written: (define (const-frac n d k) ; i counts BACKWARDS! (define (const-frac-iter i result) (if (= i 0) result (const-frac-iter (- i 1) (/ (n i) (+ (d i) result))))) (const-frac-iter k 0)) (silver-ratio 1) ; ==> 1.0 (silver-ratio 2) ; ==> 0.5 (silver-ratio 3) ; ==> 0.6666666666666666 (silver-ratio 4) ; ==> 0.6000000000000001 (silver-ratio 5) ; ==> 0.625 (silver-ratio 10) ; ==> 0.6179775280898876 (silver-ratio 15) ; ==> 0.6180344478216819 (silver-ratio 20) ; ==> 0.6180339850173578 (silver-ratio 25) ; ==> 0.6180339887802426 (silver-ratio 50) ; ==> 0.6180339887498948 The result becomes accurate to four decimal places by k=10 .","title":"Exercise 1.37"},{"location":"1-building-abstractions-using-procedures/#exercise-138","text":"; approx-e-less-2 computes the approximation of e-2 ; using Euler's continued fraction and const-frac. ; k is the number of iterations to be done (define (approx-e-less-2 k) (define (N i) 1.0) (define (D i) (if (= 2 (remainder i 3)) (* (/ (+ i 1) 3) 2) 1)) (const-frac N D k)) (approx-e-less-2 10) ; ==> 0.7182817182817183","title":"Exercise 1.38"},{"location":"1-building-abstractions-using-procedures/#exercise-139","text":"; tan-cf computes the tangent of x (radians) using const-frac. ; Note that k might have to be large if x were large. (define (tan-cf x k) (define (N i) (if (= i 1) x (- (* x x)))) (define (D i) (- (* 2 i) 1.0)) (const-frac N D k)) (tan 3) ; ==> -.1425465430742778 (tan-cf 3 10) ; ==> -.1425465438397583","title":"Exercise 1.39"},{"location":"1-building-abstractions-using-procedures/#exercise-140","text":"This is trivial to implement. ; cubic represents a cubic equation x^3+ax^2+bx+c (define (cubic a b c) (lambda (x) (+ (* x x x) (* a x x) (* b x) c)))","title":"Exercise 1.40"},{"location":"1-building-abstractions-using-procedures/#exercise-141","text":"This is also trivial to implement but somehow difficult to wrap around. ; double returns a wrapped function such that f -> f(f) where f : val -> val (define (double f) (lambda (x) (f (f x)))) (define (inc x) (+ x 1)) (((double (double double)) inc) 5) ; (((double (lambda (f) (double (double f)))) inc) 5) ; substitute the parent double ; (((lambda (f) (double (double (double (double f))))) inc) 5) ; ((double (double (double (double inc)))) 5) ; ((double (double (double (lambda (x) (inc (inc x)))))) 5) ; ((double (double (lambda (x) (inc (inc (inc (inc x))))))) 5) ; ((double (lambda (x) (inc (inc (inc (inc (inc (inc (inc (inc x)))))))))) 5) ; ((lambda (x) (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc x))))))))))))))))) 5) ; (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc (inc 5)))))))))))))))) ; ==> 21","title":"Exercise 1.41"},{"location":"1-building-abstractions-using-procedures/#exercise-142","text":"(define (compose f g) (lambda (x) (f (g x)))) ((compose square inc) 6) ; ==> 49","title":"Exercise 1.42"},{"location":"1-building-abstractions-using-procedures/#exercise-143","text":"(define (repeated f n) (define (iter i) (if (= i n) (lambda (x) x) (compose f (iter (+ i 1))))) (iter 0)) ((repeated square 2) 5) ; ==> 625 As always, an iterative solution can be found: (define (repeated f n) (define (iter result i) (if (= i n) result (iter (compose f result) (+ i 1)))) (iter f 1)) ((repeated square 2) 5) ; ==> 625","title":"Exercise 1.43"},{"location":"1-building-abstractions-using-procedures/#exercise-144","text":"; smooth returns a procedure describing a smoothed function (define (smooth f) (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)) ; smooth-n returns the n-fold smoothed function (define (smooth-n f n) (repeated smooth n))","title":"Exercise 1.44"},{"location":"1-building-abstractions-using-procedures/#exercise-145","text":"; n-th root returns a function for the n'th root of x such that ; the fixed point of y -> x/y^(n-1) is calculated, and the transformation is done r times. (define (nth-root n r) (define (average a b) (/ (+ a b) 2.0)) (lambda (x) (define (ave-dump y) (average y (/ x (expt y (- n 1))))) (fixed-point (repeated ave-dump r) 1.0))) ((nth-root 2 1) 4) ; ==> 2.000000000000002 It does not seem to work for degree 6 or higher. Maybe I'm doing something wrong here.","title":"Exercise 1.45"},{"location":"1-building-abstractions-using-procedures/#exercise-146","text":"; iterative-improve returns a procedure which gets on improved upon while it is not yet good enough. ; good-enough? returns true if the value is indeed good enough. (val ==> false) ; improve improves upon the guess (val ==> val) (define (iterative-improve good-enough? improve) (define (rinse-and-repeat x) (if (good-enough? x) x (rinse-and-repeat (improve x)))) (lambda (x) (rinse-and-repeat x))) (define (sqrt x) (define (square x) (* x x)) (define (average x y) (/ (+ x y) 2)) (define (print-approx x) (newline) (display \"Checking \") (display x)) (define (improve guess) (average guess (/ x guess))) (define (good-enough? guess) (< (abs (- (square guess) x)) 0.001)) ; multiply by 1.0 to turn to floating-point ((iterative-improve good-enough? improve) (* x 1.0))) (sqrt 103) ; ==> 10.14889156529969 (define (fixed-point f first-guess) (define (good-enough? x) (< (abs (- x (f x))) 0.000001)) (define (improve x) (f x)) ((iterative-improve good-enough? improve) first-guess)) (fixed-point cos 1.0) ; ==> .7390845495752126 Note that, with fixed-point , computing for (f x) may need to be done twice : the first time to check if the value is good enough, and the second to improve the guess.","title":"Exercise 1.46"},{"location":"2-building-abstractions-with-data/","text":"Building Abstractions with Data \u00b6 2.1 Introduction to Data Abstraction \u00b6 Exercise 2.1 \u00b6 (define (make-rat n d) (if (< d 0) (make-rat (- n) (- d)) (let ((g (abs (gcd n d)))) (cons (/ n g) (/ d g))))) Ensure that d is always positive, and make g always positive. Exercise 2.2 \u00b6 ; make-point creates a pair of x-y coordinates (define (make-point x y) (cons x y)) ; x-point and y-point return the x and y coordinates of a point p (define (x-point p) (car p)) (define (y-point p) (cdr p)) ; print-point prints details about a point (define (print-point p) (newline) (display \"(\") (display (x-point p)) (display \",\") (display (y-point p)) (display \")\")) ; make-segment creates a segment of two points (define (make-segment p1 p2) (cons p1 p2)) ; start-segment returns the first point of a segment (define (start-segment s) (car s)) ; end-segment returns the second point of a segment (define (end-segment s) (cdr s)) (define ss (make-segment (make-point 1 2) (make-point 3 4))) (print-point (start-segment ss)) ; ==> (1,2) (print-point (end-segment ss)) ; ==> (3,4) Exercise 2.3 \u00b6 ; make-rectangle creates a rectangle with c1, c2 as corners. ; Note that c1 and c2 can be anywhere in the plane, ; but the rectangle's segments will remain parallel to the x- and y-axes. ; For instance, c1=(1,4), c2=(4,2) creates a 3x2 rectangle. (define (make-rectangle c1 c2) (cons c1 c2)) ; width returns the width of the rectangle (define (width r) (abs (- (x-point (car r)) (x-point (cdr r))))) ; height returns the height of the rectangle (define (height r) (abs (- (y-point (car r)) (y-point (cdr r))))) ; perimeter computes for the perimeter of the rectangle. ; If the rectangle has zero width or height, it will return zero. (define (perimeter r) (if (or (= (width r) 0) (= (height r) 0)) 0 (* 2 (+ (width r) (height r))))) ; area returns the area of the rectangle. (define (area r) (* (width r) (height r))) All these functions can be tested as follows: (define rect (make-rectangle (make-point 1 4) (make-point 5 1))) (perimeter rect) ; ==> 14 (area rect) ; ==> 12 Exercise 2.4 \u00b6 (define (cons x y) (lambda (m) (m x y))) The procedure cons takes in two parameters x and y and returns a procedure that takes in a callable object m and returns the value (m x y) . (define (car z) (z (lambda (p q) p))) The procedure car takes in a callable object z , which in turn takes in a function that takes two callable values p and q , and then return q . This is actually a very clever way of \"implementing\" cons and car . The following is what goes on: (define pt (cons 2 3)) ; pt = (lambda (m) (m 2 3)) (car pt) ; (pt (lambda (p q) p)) ; ((lambda (m) (m 2 3)) (lambda (p q) p)) ; ((lambda (p q) p) 2 3) ; 2 Now, let us try constructing a cdr using the example for car . (define (cdr z) (z (lambda (p q) q))) (cdr pt) ; (pt (lambda (p q) q)) ; ((lambda (m) (m 2 3)) (lambda (p q) q)) ; ((lambda (p q) q) 2 3) ; 3 Exercise 2.5 \u00b6 This implementation requires repeatedly dividing the result by 2 or 3 to check how many 2's or 3's the value has. (define (cons x y) (* (expt 2 x) (expt 3 y))) (define (car p) (define (iter val res) (if (= (remainder val 2) 0) (iter (/ val 2) (+ res 1)) res)) (iter p 0)) (define (cdr p) (define (iter val res) (if (= (remainder val 3) 0) (iter (/ val 3) (+ res 1)) res)) (iter p 0)) (define pt (cons 3 4)) (car pt) ; ==> 3 (cdr pt) ; ==> 4 Exercise 2.6 \u00b6 (define zero (lambda (f) (lambda (x) x))) This defines zero as a function that takes in a function f and returns... a function that takes in x and returns the same x . (define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x))))) This defines add-1 as a procedure that takes in a callable value n and returns a function that takes in f that returns a function that takes in x and returns (f ((n f) x)) . Now that is mind-boggling... Let us try solving for (add-1 zero) : (add-1 zero) ; (add-1 (lambda (f) (lambda (x) x))) ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x)))) ; (lambda (f) (lambda (x) (f ((lambda (x) x) x)))) ; (lambda (f) (lambda (x) (f x))) Notice what happened here: (add-1 zero) takes in a function f and returns a function that takes in x and returns (f x) . Let us try to do that again. (add-1 (add-1 zero)) ; (add-1 (lambda (f) (lambda (x) (f x)))) ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x)))) ; (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x)))) ; (lambda (f) (lambda (x) (f (f x)))) Another add-1 adds a call to f . Since (add-1 zero) is just one and (add-1 one) is two , we can easily give direct definitions for them: (define one (lambda (f) (lambda (x) (f x)))) (define two (lambda (f) (lambda (x) (f (f x))))) We can also make a + procedure which takes in two \"Church numerals\" and return their sum. But how do we do this is another thing... Suppose a is a Church numeral that represents the number A in Church encoding, i.e., (lambda (f) (lambda (x) (f (f ... (f x)))))) where f is callled A times. Similarly, let b be a Church numeral that represents B in Church encoding. Note (a f) and (b f) become (lambda (x) (f (f ... (f x)))) where f is composed A and B times respectively. We would want to get a result such that the number of calls for f is A+B . Simple: ((a f) ((b f) x)) . ((b f) x) returns (f (f ... (f x))) repeated B times, and that is wrapped around (a f) which calls f A times! (define (+ a b) (lambda (f) (lambda (x) ((a f) ((b f) x))))) Exercise 2.7 \u00b6 The implementation of make-interval does not mandate a be less than b or vice versa. A check might be needed. (define (lower-bound x) (min (car x) (cdr x))) (define (upper-bound x) (max (car x) (cdr x))) Exercise 2.8 \u00b6 The difference between the two ranges is the range between the smallest possible difference to the largest possible one. The smallest possible difference can be taken by minimizing the first number and maximizing the second, while the largest possible one can be taken by maximizing the second number and minimizing the first. Suppose that the first range is 5 to 8 and the second 1 to 2. The smallest possible difference is \\(5-2=3\\) while the largest one is \\(8-1=7\\) . Implementing it should be easy. ; sub-interval determines the interval for the difference between x and y (define (sub-interval x y) (make-interval (- (lower-bound x) (upper-bound y)) (- (upper-bound x) (lower-bound y)))) (define a (make-interval 5 8)) (define b (make-interval 1 2)) (sub-interval a b) ; 3 - 7 Exercise 2.9 \u00b6 Suppose \\(x=\\left[a,b\\right]\\) and \\(y=\\left[c,d\\right]\\) , and \\(W\\left(x\\right)\\) be the width function for \\(x\\) . Hence, \\(W\\left(x\\right)=\\frac{b-a}{2}\\) and \\(W\\left(y\\right)=\\frac{d-c}{2}\\) . We see that \\(x+y=[a+c,b+d]\\) and \\(x-y=[a-d,b-c]\\) . Astonishingly, \\(W\\left(x+y\\right)=W\\left(x-y\\right)=\\frac{\\left(b+d\\right)-\\left(a+c\\right)}{2}\\) , which subsequently equals \\(W\\left(x\\right)+W\\left(y\\right)\\) . For multiplication, \\(x\\times y = \\left[\\max\\left(ac,ad,bc,bd\\right), \\min\\left(ac,ad,bc,bd\\right)\\right]\\) , and so \\(W\\left(x\\times y\\right)\\) can become uncertain, hence there is no direct relationship between that and either of \\(W\\left(x\\right)\\) and \\(W\\left(y\\right)\\) . This goes the same with division, which is dependent on multiplication. Exercise 2.10 \u00b6 (define (div-interval x y) ; spans-zero returns true if x spans zero by checking its signs (define (spans-zero x) (< (* (lower-bound x) (upper-bound x)) 0)) (if (spans-zero y) (error \"Dividend spans zero\") (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))))) (div-interval (make-interval 1 5) (make-interval 2 3)) ; returns something alright (div-interval (make-interval 1 5) (make-interval -2 3)) ; returns an error Exercise 2.11 \u00b6 Suppose \\(S\\left(x\\right)\\) has the following property: \\[ S\\left(\\left[a,b\\right]\\right) = \\left\\{\\begin{array}{lr} -1 & \\text{if } a \\lt 0 \\text{ and } b \\lt 0\\\\ 0 & \\text{if } a \\lt 0 \\text{ and } b \\ge 0\\\\ 1 & \\text{if } a \\ge 0 \\text{ and } b \\ge 0 \\end{array}\\right. \\] With \\(x=\\left[a,b\\right]\\) and \\(y=\\left[c,d\\right]\\) , there are nine possible combinations for \\(x\\times y\\) determined by their \\(S\\) -values: \\[ % painstakingly transcribed using https://isaurssaurav.github.io/mathjax-table-generator/ \\begin{array} {|r|r|}\\hline _{S(x)} \\backslash ^{S(y)} & -1 & 0 & 1 \\\\ \\hline -1 & \\left[bd,ac\\right] & \\left[ad,ac\\right] & \\left[ad,bc\\right] \\\\ \\hline 0 & \\left[bc,ac\\right] & \\star & \\left[ad,bd\\right] \\\\ \\hline 1 & \\left[bc,ad\\right] & \\left[bc,bd\\right] & \\left[ac,bd\\right] \\\\ \\hline \\end{array} \\] These ranges have been computed by hand. Consider when \\(S\\left(x\\right)=1\\) and \\(S\\left(y\\right)=0\\) . In this case, the smallest possible number could be taken from \\(b\\) , the larger positive number in the range \\(x\\) , multiplied to \\(c\\) , the smallest negative number in \\(y\\) . Similarly, the largest possible number in the product could be taken from \\(b\\) multiplied to \\(d\\) , the largest positive number in \\(y\\) . (Try using the example \\(x=\\left[1,4\\right]\\) and \\(y=\\left[-2,3\\right]\\) .) The middle case, when both \\(x\\) and \\(y\\) span zero, is a bit stranger. The negative extrema \\(bc\\) and \\(ad\\) , and the positive extrema \\(ac\\) and \\(bd\\) , can be smaller or larger than the other. One has to perform the multiplication operations manually and check the largest value from there. The following is an implementation: ; mul-interval is an implementation of multiplying two intervals ; which uses two multiplication operations most of the time (define (mul-interval x y) ; neg be less than zero and nonneg be its complement (define (neg n) (< n 0)) (define (nonneg n) (>= n 0)) ; s be the s-value of a range (define (s x) (cond ((and (neg (lower-bound x)) (neg (upper-bound x))) -1) ((and (neg (lower-bound x)) (nonneg (upper-bound x))) 0) (else 1))) ; now for the great conditional (let ((a (lower-bound x)) (b (upper-bound x)) (c (lower-bound y)) (d (upper-bound y)) (sx (s x)) (sy (s y))) (cond ((and (= sx -1) (= sy -1)) (make-interval (* b d) (* a c))) ((and (= sx -1) (= sy 0)) (make-interval (* a d) (* a c))) ((and (= sx -1) (= sy 1)) (make-interval (* a d) (* b c))) ((and (= sx 0) (= sy -1)) (make-interval (* b c) (* a c))) ; skipping sx=0 and sy=0 and putting that as the else statement ((and (= sx 0) (= sy 1)) (make-interval (* a d) (* b d))) ((and (= sx 1) (= sy -1)) (make-interval (* b c) (* a d))) ((and (= sx 1) (= sy 0)) (make-interval (* b c) (* b d))) ((and (= sx 1) (= sy 1)) (make-interval (* a c) (* b d))) (else (let ((ac (* a c)) (ad (* a d)) (bc (* b c)) (bd (* b d))) (make-interval (min ad bc) (max ac bd))))))) Tests can be done by writing two intervals, multiplying them using this and the original implementation, and checking if they are equal. How much readability one is willing to trade off for performance is dependent on the one who writes the code. Exercise 2.12 \u00b6 With some center \\(c\\) and a percent tolerance \\(p<1\\) , the range should be \\(\\left[c\\left(1-p\\right), c\\left(1+p\\right)\\right]\\) . ; make-center-percent makes an interval with center c and percent tolerance p. ; For example, if c=6.8 and p=10, the interval is between 6.8-(6.8*10%) and 6.8+(6.8*10%), ; which is 6.12 and 7.48. (define (make-center-percent c p) (make-interval (* c (- 1.0 (/ p 100.0))) (* c (+ 1.0 (/ p 100.0))))) (make-center-percent 6.8 10) ; 6.12 - 7.48 Exercise 2.13 \u00b6 Suppose there are two ranges: the first one having a center of \\(c_1\\) and percentage tolerance \\(p_1\\) , and the second having \\(c_2\\) and \\(p_2\\) . Henceforth, the two ranges are \\(\\left[{c_1}\\left(1-{p_1}\\right), {c_1}\\left(1+{p_1}\\right)\\right]\\) and \\(\\left[{c_2}\\left(1-{p_2}\\right), {c_2}\\left(1+{p_2}\\right)\\right]\\) . With the assumption that all numbers are positive, the product should have the range \\(\\left[{c_1}{c_2}\\left(1-{p_1}\\right)\\left(1-{p_2}\\right), {c_1}{c_2}\\left(1+{p_1}\\right)\\left(1+{p_2}\\right)\\right]\\) , which can be written as \\(\\left[{c_1}{c_2}\\left(1-\\left({p_1}+{p_2}\\right)+{p_1}{p_2}\\right), {c_1}{c_2}\\left(1+\\left({p_1}+{p_2}\\right)+{p_1}{p_2}\\right)\\right]\\) . If \\(p_1\\) and \\(p_2\\) are sufficiently small, \\({p_1}{p_2}\\) can be negligible, and the range is written as \\(\\left[{c_1}{c_2}\\left(1-\\left({p_1}+{p_2}\\right)\\right), {c_1}{c_2}\\left(1+\\left({p_1}+{p_2}\\right)\\right)\\right]\\) , which is a range with center \\({c_1}{c_2}\\) and percentage tolerance \\({p_1}+{p_2}\\) . Exercise 2.14 \u00b6 Using a simple test, we see that the two procedures do output different values: (define r1 (make-center-percent 6800 10)) (define r2 (make-center-percent 3000 25)) (par1 r1 r2) ; (1226.179875333927 . 3351.2544802867387) (par2 r1 r2) ; (1645.1612903225807 . 2497.773820124666) Suppose \\(x=\\left[a,b\\right]\\) and \\(y=\\left[c,d\\right]\\) . We see that \\(x+y=\\left[a+c,b+d\\right]\\) and \\(x\\times y=\\left[ac, bd\\right]\\) . Let us consider, however, what div-interval does: (define (div-interval x y) (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y))))) Or, in mathematical terms: \\[ \\begin{aligned} \\left[a,b\\right]\\div\\left[c,d\\right] &= \\left[a,b\\right]\\times \\left[\\frac{1}{d}, \\frac{1}{c}\\right] \\\\ &= \\left[\\frac{a}{d}, \\frac{b}{c}\\right] \\end{aligned} \\] Interestingly, if we have a range \\([a,b]\\) divided by itself: \\[ \\begin{aligned} \\left[a,b\\right]\\div\\left[a,b\\right] &= \\left[\\frac{a}{b}, \\frac{b}{a}\\right] \\end{aligned} \\] The current system does not have an identity principle. More on this later. From here, we can analyze the behaviors of par1 and par2 : \\[ \\begin{aligned} \\text{par1}\\left(x,y\\right) &= \\left(x\\times y\\right) \\div \\left(x+y\\right) \\\\ &= \\left[ac, bd\\right] \\div \\left[a+c, b+d\\right] \\\\ &= \\left[\\frac{ac}{b+d}, \\frac{bd}{a+c}\\right] \\end{aligned} \\] \\[ \\begin{aligned} \\text{par2}\\left(x,y\\right) &= \\left[1, 1\\right] \\div \\left(\\left(\\left[1,1\\right] \\div x\\right) + \\left(\\left[1,1\\right] \\div y\\right)\\right) \\\\ &= \\left[1,1\\right] \\div \\left(\\left(\\left[1,1\\right] \\div \\left[a,b\\right]\\right) + \\left(\\left[1,1\\right] \\div \\left[c,d\\right]\\right)\\right) \\\\ &= \\left[1,1\\right] \\div \\left(\\left[\\frac{1}{b}, \\frac{1}{a}\\right] + \\left[\\frac{1}{d}, \\frac{1}{c}\\right]\\right) \\\\ &= \\left[1,1\\right] \\div \\left(\\left[\\frac{1}{b} + \\frac{1}{d}, \\frac{1}{a} + \\frac{1}{c}\\right]\\right) \\\\ &= \\left[\\frac{1}{\\frac{1}{a} + \\frac{1}{c}} , \\frac{1}{\\frac{1}{b} + \\frac{1}{d}} \\right] \\\\ &= \\left[\\frac{ac}{a+c} , \\frac{bd}{b+d} \\right] \\end{aligned} \\] Exercise 2.15 \u00b6 Let us consider the results of the previous exercise. We have to remember that \\(a<b\\) and \\(c<d\\) . Therefore, \\(a+c < b+d\\) , and this implies that \\(\\left[\\frac{ac}{b+d}, \\frac{bd}{a+c}\\right]\\) has a wider range than \\(\\left[\\frac{ac}{a+c} , \\frac{bd}{b+d} \\right]\\) because of the denominators of the parameters of the former. While it may be computationally cheaper to compute for \\({x}\\times{y}\\) in par1 , this will introduce a much larger range than par2 . This is perhaps the \"uncertainty\" that Eva Lu Ator is describing. Exercise 2.16 \u00b6 Consider the lack of identity in div-interval . Because of this, \\(x + y \\div y \\neq x\\) . The two expressions should be equivalent, but they aren't. A principle of \"identity\" should be established where a program knows if an operation is applied to two \"same\" intervals, although doing so is a lot harder than it looks, and I can't say if it even were possible. 2.2 Hierarchial Data and the Closure Property \u00b6 Exercise 2.17 \u00b6 ; last-pair returns a pair which only contains the last element of a given list (define (last-pair items) (if (null? (cdr items)) items (last-pair (cdr items)))) (last-pair (list 23 72 149 34)) ; (34) Exercise 2.18 \u00b6 Note that (cdr items) returns either a list or nil, and (car items) returns a single number. From here, how are we able to reverse a list? Of course, without using the built-in reverse . Remember that last-pair takes in the last \"pair\" of the list (its cdr is an empty value, so really it's a pair with only one element). This can be a very useful procedure. A reverse procedure would use last-pair to get the very last item, and a all-but-last procedure which returns the entire list without the very last element. (define (all-but-last items) (if (null? (cdr items)) () (cons (car items) (all-but-last (cdr items))))) (all-but-last (list 23 72 149 34)) ; (23 72 149) (define (reverse items) (if (null? items) items (cons (car (last-pair items)) (reverse (all-but-last items))))) (reverse (list 23 72 149 34)) ; (34 149 72 23) Exercise 2.19 \u00b6 ; first-denomination returns the first item on items (define (first-denomination items) (car items)) ; except-first-denomination returns items but the first one (define (except-first-denomination items) (cdr items)) ; no-more? checks if items is empty (define (no-more? items) (null? items)) ; using the previous procedures, as well as those in the book (cc 100 us-coins) ; 292 On whether order matters for coin-values , after every iteration, cc branches between when first-denomination has been chosen, and when it isn't and first-denomination is no longer available as an option. The order of the coins should not matter, since all permutations will be attempted. A simple demonstration of this, although definitely not solid proof, can be seen if us-coins were reversed: (cc 100 (reverse us-coins)) ; also 292 Exercise 2.20 \u00b6 (define (same-parity . items) (define (is-same-parity? x) (= (remainder (car items) 2) (remainder x 2))) (filter is-same-parity? items)) (same-parity 1 2 3 4 5 6 7) ; (1 3 5 7) (same-parity 2 3 4 5 6 7) ; (2 4 6) Wait, we aren't allowed to use filter yet? Okay then. (define (same-parity . items) (define (is-same-parity? x) (= (remainder (car items) 2) (remainder x 2))) ; recurse recurses through items with is-same-parity? and returns accum (define (recurse items accum) (cond ((null? items) accum) ((is-same-parity? (car items)) (recurse (cdr items) (cons (car items) accum))) (else (recurse (cdr items) accum)))) ; one call to reverse since accum appends to the left every time (reverse (recurse items ()))) (same-parity 1 2 3 4 5 6 7) ; (1 3 5 7) (same-parity 2 3 4 5 6 7) ; (2 4 6) Exercise 2.21 \u00b6 (define (square-list items) (if (null? items) () ; \"nil\" (cons (square (car items)) (square-list (cdr items))))) (square-list (list 1 2 3 4)) (define (square-list items) (map square items)) (square-list (list 1 2 3 4)) Exercise 2.22 \u00b6 (define (square-list items) (define (iter things answer) (if (null? things) answer (iter (cdr things) (cons (square (car things)) answer)))) (iter items ())) (square-list (list 1 2 3 4)) ; (iter (list 1 2 3 4) ()) ; (iter (list 2 3 4) (cons (square 1) ())) ; (iter (list 2 3 4) (list 1)) ; (iter (list 3 4) (cons (square 2) (list 1))) ; (iter (list 3 4) (list 4 1)) ; (iter (list 4) (cons (square 3) (list 4 1))) ; (iter (list 4) (list 9 4 1)) ; (iter () (cons (square 4) (list 9 4 1))) ; (iter () (list 16 9 4 1)) ; (list 16 9 4 1) For every subsequent value taken from things , it is appended at the start of answer . The answers are stacked FILO. (define (square-list items) (define (iter things answer) (if (null? things) answer (iter (cdr things) (cons answer (square (car things)))))) (iter items ())) (square-list (list 1 2 3 4)) ; (iter (list 1 2 3 4) ()) ; (iter (list 2 3 4) (cons () (square 1))) ; (iter (list 2 3 4) (list () 1)) ; (iter (list 3 4) (cons (list () 1) (square 2))) ; (iter (list 3 4) (list (list () 1) 4)) ; (iter (list 4) (cons (list (list () 1) 4) (square 3))) ; (iter (list 4) (list (list (list () 1) 4) 9)) ; (iter () (cons (list (list (list () 1) 4) 9) (square 4))) ; (iter () (list (list (list (list () 1) 4) 9) 16)) ; (list (list (list (list () 1) 4) 9) 16) The problem here is that a list is cons 'd to a value, which should be the other way around. The final pair has a list in its first half, and a single value at its second. This will yield MIT Scheme to display something weird: 1 ]=> (square-list (list 1 2 3 4)) ;Value: ((((() . 1) . 4) . 9) . 16) Exercise 2.23 \u00b6 (define (for-each f items) (define (execute-and-iterate f items) (f (car items)) (for-each f (cdr items))) (if (not (null? items)) (execute-and-iterate f items))) (for-each (lambda (x) (newline) (display x)) (list 57 321 88)) ; 57 ; 321 ; 88 ; returns unspecified value Exercise 2.24 \u00b6 1 ]=> (list 1 (list 2 (list 3 4))) ;Value: (1 (2 (3 4))) This looks like an interesting list. Let us graph it, then. Notice, that this graph represents three lists, each of length 2. This is different from (list 1 2 3 4) , which would return a single list of length 4. Exercise 2.25 \u00b6 (car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9)))))) ; 7 (car (car (list (list 7)))) ; 7 (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))))))))))) ; 7 Exercise 2.26 \u00b6 (define x (list 1 2 3)) (define y (list 4 5 6)) ; append appends two lists and combines their items (append x y) ; (1 2 3 4 5 6) ; cons creates a cons pair of two items. Note that y is \"linked\" to the result (cons x y) ; ((1 2 3) 4 5 6) ; list creates a list of the items it is provided with (list x y) ; ((1 2 3) (4 5 6)) Exercise 2.27 \u00b6 This is quite an interesting one. A reversal must also be done not only to the list in question, but to the items of the items if they do exist. (define (all-but-last items) (if (null? (cdr items)) () (cons (car items) (all-but-last (cdr items))))) (all-but-last (list 23 72 149 34)) ; (23 72 149) ; deep-reverse reverses items and its subitems (define (deep-reverse items) (cond ((null? items) items) ((not (list? items)) items) (else (cons (deep-reverse (car (last-pair items))) (deep-reverse (all-but-last items)))))) (define x (list (list 1 2) (list 3 4))) (reverse x) ; ((3 4) (1 2)) (deep-reverse x) ; ((4 3) (2 1)) Exercise 2.28 \u00b6 ; fringe takes in items and returns a single flattened list (define (fringe items) (cond ((null? items) items) ((not (list? items)) (list items)) (else (append (fringe (car items)) (fringe (cdr items)))))) (define x (list (list 1 2) (list 3 4))) (fringe x) ; (1 2 3 4) (fringe (list x x)) ; (1 2 3 4 1 2 3 4) Exercise 2.29 \u00b6 The following are the selectors for the mobile and branch structures defined by make-mobile and make-branch : ; left-branch returns the left branch of a mobile (define (left-branch mobile) (car mobile)) ; right-branch returns the right branch of a mobile (define (right-branch mobile) (car (cdr mobile))) ; branch-length returns the length of a branch (define (branch-length branch) (car branch)) ; branch-structure returns the structure attached to the branch (define (branch-structure branch) (car (cdr branch))) The following is an implementation for total-weight : ; total-weight returns the total weight of a mobile. Returns itself if mobile is a number. (define (total-weight mobile) (if (pair? mobile) ; i.e., mobile is represented by a pair i.e., it *is* a mobile (+ (total-weight (branch-structure (left-branch mobile))) (total-weight (branch-structure (right-branch mobile)))) mobile)) Why I used pair? instead of list? is such that, in a later problem, the mobile and branch structures will be represented by cons instead of list . All cons are list s but not the other way around! The following is an implementation for balanced? : ; torque returns the torque of a branch (define (torque branch) (* (branch-length branch) (total-weight (branch-structure branch)))) ; balanced? checks if a mobile is balanced. Returns true if mobile is a number (define (balanced? mobile) (if (not (pair? mobile)) #t (= (torque (left-branch mobile)) (torque (right-branch mobile))))) Going to the fourth problem, by doing this, we would only need to change (car (cdr ...)) to (cdr ...) : ; left-branch returns the left branch of a mobile (define (left-branch mobile) (car mobile)) ; right-branch returns the right branch of a mobile (define (right-branch mobile) (cdr mobile)) ; branch-length returns the length of a branch (define (branch-length branch) (car branch)) ; branch-structure returns the structure attached to the branch (define (branch-structure branch) (cdr branch)) Exercise 2.30 \u00b6 ; square-tree squares a tree (define (square-tree tree) (map (lambda (sub-tree) (if (pair? sub-tree) (square-tree sub-tree) (square sub-tree))) tree)) (square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))) ; ==> (1 (4 (9 16) 25) (36 49)) Exercise 2.31 \u00b6 ; tree-map maps f to tree such that element -> (f element) (define (tree-map f tree) (map (lambda (sub-tree) (if (pair? sub-tree) (tree-map f sub-tree) (f sub-tree))) tree)) Exercise 2.32 \u00b6 For each element e which is an element of S , all subsets of S will either have e , or not. (define (subsets s) (if (null? s) (list ()) (let ((rest (subsets (cdr s)))) (append rest (map (lambda (subset) (cons (car s) subset)) rest))))) (subsets (list 1 2 3)) ; ==> (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)) The return value is the combination of rest , which are the subsets of cdr s , and (map (lambda (subset) (cons (car s) subset)) rest) , which is car s appended to each value of rest . Every element in the return value will either have car s or not. Exercise 2.33 \u00b6 map is defined as accumulating a list using sequence by repeatedly applying (p elem) to every elem : (define (map p sequence) (accumulate (lambda (x y) (cons (p x) y)) () sequence)) append performs a cons for every elem of seq1 into seq2 : (define (append seq1 seq2) (accumulate cons seq2 seq1)) length iterates the value by 1 every time an element is encountered: (define (length sequence) (accumulate (lambda (_ y) (+ y 1)) 0 sequence)) Exercise 2.34 \u00b6 In the problem statement, the keyword higher-terms was used, which was a bit of a misnomer and threw me off for a while. ; horner-eval performs a Horner evaluation on coefficient-sequence with a particular x. (define (horner-eval x coefficient-sequence) (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* higher-terms x))) 0 coefficient-sequence)) (horner-eval 2 (list 1 3 0 5 0 1)) ; ==> 79 Exercise 2.35 \u00b6 ; count-leaves counts the number of leaves in t (define (count-leaves t) (accumulate (lambda (current-value total) (+ total (length current-value))) 0 (map enumerate-tree t))) Exercise 2.36 \u00b6 ; accumulate-n takes in a sequence of sequences and accumulates using op and init. (define (accumulate-n op init seqs) (if (null? (car seqs)) () (cons (accumulate op init (map car seqs)) (accumulate-n op init (map cdr seqs))))) (define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12))) (accumulate-n + 0 s) ; ==> (22 26 30) Inside the cons statement, we combine two values: the accumulated result of the first items of seqs , and the results of the remaining items of seqs . To get the first items of seqs , (map car seqs) is used, where every sequence is mapped to car thus returning the first item. Similarly, to get the remaining items of seqs , (map cdr seqs) is used. Exercise 2.37 \u00b6 ; matrix-*-vector performs a multiplication between a matrix and a vector ; and returns a vector (define (matrix-*-vector m v) (map (lambda (row) (dot-product row v)) m)) ; Example from https://mathinsight.org/matrix_vector_multiplication (matrix-*-vector (list (list 1 -1 2) (list 0 -3 1)) (list 2 1 0)) ; (1 -3) ; transpose transposes a matrix (define (transpose mat) (accumulate-n cons ; used to append each element for every column in the matrix () mat)) ; Example from https://en.wikipedia.org/wiki/Transpose (transpose (list (list 1 2) (list 3 4) (list 5 6))) ; ((1 3 5) (2 4 6)) ; matrix-*-matrix performs a multiplication between two matrices (define (matrix-*-matrix m n) (let ((cols (transpose n))) (map (lambda (row) (matrix-*-vector cols row)) m))) ; Example from https://mathinsight.org/matrix_vector_multiplication (matrix-*-matrix (list (list 0 4 -2) (list -4 -3 0)) (list (list 0 1) (list 1 -1) (list 2 3))) ; ((0 -10) (-3 -1)) Exercise 2.38 \u00b6 For the first pair of statements: (fold-right / 1 (list 1 2 3)) ; (/ 1 (fold-right / 1 (list 2 3))) ; (/ 1 (/ 2 (fold-right / 1 (list 3)))) ; (/ 1 (/ 2 (/ 3 (fold-right / 1 ())))) ; (/ 1 (/ 2 (/ 3 1))) ; (/ 1 (/ 2 3)) ; (/ 1 (0.667)) ; using floating-points instead of rationals for this showcasing ; ==> 1.5 (fold-left / 1 (list 1 2 3)) ; (iter 1 (list 1 2 3)) ; (iter (/ 1 1) (list 2 3)) ; (iter 1 (list 2 3)) ; (iter (/ 1 2) (list 3)) ; (iter 0.5 (list 3)) ; (iter (/ 0.5 3) ()) ; (iter 0.167 ()) ; ==> 0.167 The first statement was \\(1 \\div \\left(2 \\div 3\\right)\\) , while the second one was \\(\\left(1 \\div 2\\right) \\div 3\\) For the second pair of statements: (fold-right list () (list 1 2 3)) ; (list 1 (fold-right list () (list 2 3))) ; (list 1 (list 2 (fold-right list () (list 3)))) ; (list 1 (list 2 (list 3 (fold-right list () ())))) ; (list 1 (list 2 (list 3 ()))) ; ==> (1 (2 (3 ()))) (fold-left list () (list 1 2 3)) ; (iter () (list 1 2 3)) ; (iter (list () 1) (list 2 3)) ; (iter (list (list () 1) 2) (list 3)) ; (iter (list (list (list () 1) 2) 3) ()) ; ==> (((() 1) 2) 3) For fold-left and fold-right to have the same result, (op a b) must equal (op b a) , that is, the order of operations ought not matter. Exercise 2.39 \u00b6 (define (reverse sequence) (fold-right (lambda (x y) (append y (list x))) () sequence)) (reverse (list 1 2 3 4)) ; (4 3 2 1) (define (reverse sequence) (fold-left (lambda (x y) (cons y x)) () sequence)) (reverse (list 1 2 3 4)) ; (4 3 2 1) Exercise 2.40 \u00b6 ; unique-pairs generates a sequence of (i,j) with 1<=j<i<=n. (define (unique-pairs n) (flatmap (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1)))) (enumerate-interval 1 n))) (unique-pairs 6) ; prime-sum-pairs generates a sequence of (i,j) from unique-pairs ; such that i+j is prime (define (prime-sum-pairs n) ; sum gets the sum of the values of a pair (define (sum p) (+ (car p) (cadr p))) (map (lambda (p) (append p (list (sum p)))) (filter (lambda (p) (prime? (sum p))) (unique-pairs n)))) (prime-sum-pairs 6) Exercise 2.41 \u00b6 ; triples-with-sum returns a sequence of ordered pairs (i,j,k) ; such that i+j+k=s (define (triples-with-sum s) (flatmap (lambda (i) (map (lambda (j) (list i j (- s i j))) (enumerate-interval 1 (- s i 1)))) (enumerate-interval 1 s))) (triples-with-sum 6) ; ((1 1 4) (1 2 3) (1 3 2) (1 4 1) (2 1 3) (2 2 2) (2 3 1) (3 1 2) (3 2 1) (4 1 1)) Exercise 2.42 \u00b6 The convention I used for a position in the board would be a pair made using cons . ; a position is represented using a cons where col, row are from 1 to n ; where the queens are arranged in an nxn grid (define (position col row) (cons col row)) ; col and row get the col and row of a position (define (col position) (car position)) (define (row position) (cdr position)) ; adjoin-position adjoins a new row-column position to a set of positions (define (adjoin-position new-row k rest-of-queens) (append rest-of-queens (list (position k new-row)))) With regards to checking safety, same-row? , same-col? and same-diag? are written to check if two positions fall in the same row, column, or diagonal. I had to check for every pair of positions (pos, key) where pos is positions except key , and key is the only position which has a column k . ; empty-board represents an empty set of positions (define empty-board ()) ; safe? determines whether the queen in the k'th column is safe w/ respect to others (define (safe? k positions) ; suppose there are two positions a and b. ; let's do some checks... ; same-row? returns true if a, b have the same row (define (same-row? a b) (= (row a) (row b))) ; same-col? returns true if a, b have the same column (define (same-col? a b) (= (col a) (col b))) ; same-diag? returns true if a, b can be found diagonally (define (same-diag? a b) (= (abs (- (row a) (row b))) (abs (- (col a) (col b))))) ; relatively-safe? returns #t if a, b share neither row nor col nor diag (define (relatively-safe? a b) (and (not (same-row? a b)) (not (same-col? a b)) (not (same-diag? a b)))) ; positions-but returns positions but itself (define (positions-but itself) (filter (lambda (pos) (not (and (= (row pos) (row itself)) (= (col pos) (col itself))))) positions)) ; key-position returns the position whose column is k *and return the first value* (define (key-position k) (car (filter (lambda (pos) (= (col pos) k)) positions))) ; all-true makes sure all of elems are equal to true (define (all-true elems) (accumulate (lambda (acc cnt) (if (not cnt) ; cnt == #f #f acc)) ; if acc were #f then cnt becomes #f and it stays #f #t elems)) (let ((key (key-position k))) (all-true (map (lambda (pos) (relatively-safe? key pos)) (positions-but key))))) Running (queens 8) yields all 92 potential solutions to the Eight Queens puzzle. ; queens returns all possible solutions to the eight-queens puzzle (define (queens board-size) ; queen-cols list the possible solutions to eight-queens on a kxk grid (define (queen-cols k) (if (= k 0) (list empty-board) (filter (lambda (positions) (safe? k positions)) (flatmap (lambda (rest-of-queens) (map (lambda (new-row) (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size))) (queen-cols (- k 1)))))) (queen-cols board-size)) (queens 8) ; ((1 . 1) (2 . 5) (3 . 8) (4 . 6) (5 . 3) (6 . 7) (7 . 2) (8 . 4)) ; ((1 . 1) (2 . 6) (3 . 8) (4 . 3) (5 . 7) (6 . 4) (7 . 2) (8 . 5)) ; ((1 . 1) (2 . 7) (3 . 4) (4 . 6) (5 . 8) (6 . 2) (7 . 5) (8 . 3)) ; ((1 . 1) (2 . 7) (3 . 5) (4 . 8) (5 . 2) (6 . 4) (7 . 6) (8 . 3)) ; ((1 . 2) (2 . 4) (3 . 6) (4 . 8) (5 . 3) (6 . 1) (7 . 7) (8 . 5)) ; ((1 . 2) (2 . 5) (3 . 7) (4 . 1) (5 . 3) (6 . 8) (7 . 6) (8 . 4)) ; ((1 . 2) (2 . 5) (3 . 7) (4 . 4) (5 . 1) (6 . 8) (7 . 6) (8 . 3)) ; ((1 . 2) (2 . 6) (3 . 1) (4 . 7) (5 . 4) (6 . 8) (7 . 3) (8 . 5)) ; ((1 . 2) (2 . 6) (3 . 8) (4 . 3) (5 . 1) (6 . 4) (7 . 7) (8 . 5)) ; ((1 . 2) (2 . 7) (3 . 3) (4 . 6) (5 . 8) (6 . 5) (7 . 1) (8 . 4)) ; ((1 . 2) (2 . 7) (3 . 5) (4 . 8) (5 . 1) (6 . 4) (7 . 6) (8 . 3)) ; ((1 . 2) (2 . 8) (3 . 6) (4 . 1) (5 . 3) (6 . 5) (7 . 7) (8 . 4)) ; ((1 . 3) (2 . 1) (3 . 7) (4 . 5) (5 . 8) (6 . 2) (7 . 4) (8 . 6)) ; ((1 . 3) (2 . 5) (3 . 2) (4 . 8) (5 . 1) (6 . 7) (7 . 4) (8 . 6)) ; ((1 . 3) (2 . 5) (3 . 2) (4 . 8) (5 . 6) (6 . 4) (7 . 7) (8 . 1)) ; ((1 . 3) (2 . 5) (3 . 7) (4 . 1) (5 . 4) (6 . 2) (7 . 8) (8 . 6)) ; ((1 . 3) (2 . 5) (3 . 8) (4 . 4) (5 . 1) (6 . 7) (7 . 2) (8 . 6)) ; ((1 . 3) (2 . 6) (3 . 2) (4 . 5) (5 . 8) (6 . 1) (7 . 7) (8 . 4)) ; ((1 . 3) (2 . 6) (3 . 2) (4 . 7) (5 . 1) (6 . 4) (7 . 8) (8 . 5)) ; ((1 . 3) (2 . 6) (3 . 2) (4 . 7) (5 . 5) (6 . 1) (7 . 8) (8 . 4)) ; ((1 . 3) (2 . 6) (3 . 4) (4 . 1) (5 . 8) (6 . 5) (7 . 7) (8 . 2)) ; ((1 . 3) (2 . 6) (3 . 4) (4 . 2) (5 . 8) (6 . 5) (7 . 7) (8 . 1)) ; ((1 . 3) (2 . 6) (3 . 8) (4 . 1) (5 . 4) (6 . 7) (7 . 5) (8 . 2)) ; ((1 . 3) (2 . 6) (3 . 8) (4 . 1) (5 . 5) (6 . 7) (7 . 2) (8 . 4)) ; ((1 . 3) (2 . 6) (3 . 8) (4 . 2) (5 . 4) (6 . 1) (7 . 7) (8 . 5)) ; ((1 . 3) (2 . 7) (3 . 2) (4 . 8) (5 . 5) (6 . 1) (7 . 4) (8 . 6)) ; ((1 . 3) (2 . 7) (3 . 2) (4 . 8) (5 . 6) (6 . 4) (7 . 1) (8 . 5)) ; ((1 . 3) (2 . 8) (3 . 4) (4 . 7) (5 . 1) (6 . 6) (7 . 2) (8 . 5)) ; ((1 . 4) (2 . 1) (3 . 5) (4 . 8) (5 . 2) (6 . 7) (7 . 3) (8 . 6)) ; ((1 . 4) (2 . 1) (3 . 5) (4 . 8) (5 . 6) (6 . 3) (7 . 7) (8 . 2)) ; ((1 . 4) (2 . 2) (3 . 5) (4 . 8) (5 . 6) (6 . 1) (7 . 3) (8 . 7)) ; ((1 . 4) (2 . 2) (3 . 7) (4 . 3) (5 . 6) (6 . 8) (7 . 1) (8 . 5)) ; ((1 . 4) (2 . 2) (3 . 7) (4 . 3) (5 . 6) (6 . 8) (7 . 5) (8 . 1)) ; ((1 . 4) (2 . 2) (3 . 7) (4 . 5) (5 . 1) (6 . 8) (7 . 6) (8 . 3)) ; ((1 . 4) (2 . 2) (3 . 8) (4 . 5) (5 . 7) (6 . 1) (7 . 3) (8 . 6)) ; ((1 . 4) (2 . 2) (3 . 8) (4 . 6) (5 . 1) (6 . 3) (7 . 5) (8 . 7)) ; ((1 . 4) (2 . 6) (3 . 1) (4 . 5) (5 . 2) (6 . 8) (7 . 3) (8 . 7)) ; ((1 . 4) (2 . 6) (3 . 8) (4 . 2) (5 . 7) (6 . 1) (7 . 3) (8 . 5)) ; ((1 . 4) (2 . 6) (3 . 8) (4 . 3) (5 . 1) (6 . 7) (7 . 5) (8 . 2)) ; ((1 . 4) (2 . 7) (3 . 1) (4 . 8) (5 . 5) (6 . 2) (7 . 6) (8 . 3)) ; ((1 . 4) (2 . 7) (3 . 3) (4 . 8) (5 . 2) (6 . 5) (7 . 1) (8 . 6)) ; ((1 . 4) (2 . 7) (3 . 5) (4 . 2) (5 . 6) (6 . 1) (7 . 3) (8 . 8)) ; ((1 . 4) (2 . 7) (3 . 5) (4 . 3) (5 . 1) (6 . 6) (7 . 8) (8 . 2)) ; ((1 . 4) (2 . 8) (3 . 1) (4 . 3) (5 . 6) (6 . 2) (7 . 7) (8 . 5)) ; ((1 . 4) (2 . 8) (3 . 1) (4 . 5) (5 . 7) (6 . 2) (7 . 6) (8 . 3)) ; ((1 . 4) (2 . 8) (3 . 5) (4 . 3) (5 . 1) (6 . 7) (7 . 2) (8 . 6)) ; ((1 . 5) (2 . 1) (3 . 4) (4 . 6) (5 . 8) (6 . 2) (7 . 7) (8 . 3)) ; ((1 . 5) (2 . 1) (3 . 8) (4 . 4) (5 . 2) (6 . 7) (7 . 3) (8 . 6)) ; ((1 . 5) (2 . 1) (3 . 8) (4 . 6) (5 . 3) (6 . 7) (7 . 2) (8 . 4)) ; ((1 . 5) (2 . 2) (3 . 4) (4 . 6) (5 . 8) (6 . 3) (7 . 1) (8 . 7)) ; ((1 . 5) (2 . 2) (3 . 4) (4 . 7) (5 . 3) (6 . 8) (7 . 6) (8 . 1)) ; ((1 . 5) (2 . 2) (3 . 6) (4 . 1) (5 . 7) (6 . 4) (7 . 8) (8 . 3)) ; ((1 . 5) (2 . 2) (3 . 8) (4 . 1) (5 . 4) (6 . 7) (7 . 3) (8 . 6)) ; ((1 . 5) (2 . 3) (3 . 1) (4 . 6) (5 . 8) (6 . 2) (7 . 4) (8 . 7)) ; ((1 . 5) (2 . 3) (3 . 1) (4 . 7) (5 . 2) (6 . 8) (7 . 6) (8 . 4)) ; ((1 . 5) (2 . 3) (3 . 8) (4 . 4) (5 . 7) (6 . 1) (7 . 6) (8 . 2)) ; ((1 . 5) (2 . 7) (3 . 1) (4 . 3) (5 . 8) (6 . 6) (7 . 4) (8 . 2)) ; ((1 . 5) (2 . 7) (3 . 1) (4 . 4) (5 . 2) (6 . 8) (7 . 6) (8 . 3)) ; ((1 . 5) (2 . 7) (3 . 2) (4 . 4) (5 . 8) (6 . 1) (7 . 3) (8 . 6)) ; ((1 . 5) (2 . 7) (3 . 2) (4 . 6) (5 . 3) (6 . 1) (7 . 4) (8 . 8)) ; ((1 . 5) (2 . 7) (3 . 2) (4 . 6) (5 . 3) (6 . 1) (7 . 8) (8 . 4)) ; ((1 . 5) (2 . 7) (3 . 4) (4 . 1) (5 . 3) (6 . 8) (7 . 6) (8 . 2)) ; ((1 . 5) (2 . 8) (3 . 4) (4 . 1) (5 . 3) (6 . 6) (7 . 2) (8 . 7)) ; ((1 . 5) (2 . 8) (3 . 4) (4 . 1) (5 . 7) (6 . 2) (7 . 6) (8 . 3)) ; ((1 . 6) (2 . 1) (3 . 5) (4 . 2) (5 . 8) (6 . 3) (7 . 7) (8 . 4)) ; ((1 . 6) (2 . 2) (3 . 7) (4 . 1) (5 . 3) (6 . 5) (7 . 8) (8 . 4)) ; ((1 . 6) (2 . 2) (3 . 7) (4 . 1) (5 . 4) (6 . 8) (7 . 5) (8 . 3)) ; ((1 . 6) (2 . 3) (3 . 1) (4 . 7) (5 . 5) (6 . 8) (7 . 2) (8 . 4)) ; ((1 . 6) (2 . 3) (3 . 1) (4 . 8) (5 . 4) (6 . 2) (7 . 7) (8 . 5)) ; ((1 . 6) (2 . 3) (3 . 1) (4 . 8) (5 . 5) (6 . 2) (7 . 4) (8 . 7)) ; ((1 . 6) (2 . 3) (3 . 5) (4 . 7) (5 . 1) (6 . 4) (7 . 2) (8 . 8)) ; ((1 . 6) (2 . 3) (3 . 5) (4 . 8) (5 . 1) (6 . 4) (7 . 2) (8 . 7)) ; ((1 . 6) (2 . 3) (3 . 7) (4 . 2) (5 . 4) (6 . 8) (7 . 1) (8 . 5)) ; ((1 . 6) (2 . 3) (3 . 7) (4 . 2) (5 . 8) (6 . 5) (7 . 1) (8 . 4)) ; ((1 . 6) (2 . 3) (3 . 7) (4 . 4) (5 . 1) (6 . 8) (7 . 2) (8 . 5)) ; ((1 . 6) (2 . 4) (3 . 1) (4 . 5) (5 . 8) (6 . 2) (7 . 7) (8 . 3)) ; ((1 . 6) (2 . 4) (3 . 2) (4 . 8) (5 . 5) (6 . 7) (7 . 1) (8 . 3)) ; ((1 . 6) (2 . 4) (3 . 7) (4 . 1) (5 . 3) (6 . 5) (7 . 2) (8 . 8)) ; ((1 . 6) (2 . 4) (3 . 7) (4 . 1) (5 . 8) (6 . 2) (7 . 5) (8 . 3)) ; ((1 . 6) (2 . 8) (3 . 2) (4 . 4) (5 . 1) (6 . 7) (7 . 5) (8 . 3)) ; ((1 . 7) (2 . 1) (3 . 3) (4 . 8) (5 . 6) (6 . 4) (7 . 2) (8 . 5)) ; ((1 . 7) (2 . 2) (3 . 4) (4 . 1) (5 . 8) (6 . 5) (7 . 3) (8 . 6)) ; ((1 . 7) (2 . 2) (3 . 6) (4 . 3) (5 . 1) (6 . 4) (7 . 8) (8 . 5)) ; ((1 . 7) (2 . 3) (3 . 1) (4 . 6) (5 . 8) (6 . 5) (7 . 2) (8 . 4)) ; ((1 . 7) (2 . 3) (3 . 8) (4 . 2) (5 . 5) (6 . 1) (7 . 6) (8 . 4)) ; ((1 . 7) (2 . 4) (3 . 2) (4 . 5) (5 . 8) (6 . 1) (7 . 3) (8 . 6)) ; ((1 . 7) (2 . 4) (3 . 2) (4 . 8) (5 . 6) (6 . 1) (7 . 3) (8 . 5)) ; ((1 . 7) (2 . 5) (3 . 3) (4 . 1) (5 . 6) (6 . 8) (7 . 2) (8 . 4)) ; ((1 . 8) (2 . 2) (3 . 4) (4 . 1) (5 . 7) (6 . 5) (7 . 3) (8 . 6)) ; ((1 . 8) (2 . 2) (3 . 5) (4 . 3) (5 . 1) (6 . 7) (7 . 4) (8 . 6)) ; ((1 . 8) (2 . 3) (3 . 1) (4 . 6) (5 . 2) (6 . 5) (7 . 7) (8 . 4)) ; ((1 . 8) (2 . 4) (3 . 1) (4 . 3) (5 . 6) (6 . 2) (7 . 7) (8 . 5)) Exercise 2.43 \u00b6 Let us first consider our original program: (flatmap (lambda (rest-of-queens) (map (lambda (new-row) (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size))) (queen-cols (- k 1)))) and let us look at Louis Reasoner's code: (flatmap (lambda (new-row) (map (lambda (rest-of-queens) (adjoin-position new-row k rest-of-queens)) (queen-cols (- k 1)))) (enumerate-interval 1 board-size)) We know that the order of operations have been swapped, but why does the second block of code run much, much slower than the first one? It took almost instantly to run (queens 6) originally, whereas it took around 4 seconds with the mistake. Consider that, at the first block of code, that queen-cols should only be called once, as a parameter of flatmap . However, at the second block of code, queen-cols is called board-size number of times since, for every value of (enumerate-interval 1 board-size) , the value is passed onto the lambda which calls queen-cols every time that happpens. It took around 91 milliseconds to run the Eight Queens problem but it took 70434 milliseconds to run Louis's version. I can't explain the discrepancy well but this blogpost by Werner de Groot can. Exercise 2.44 \u00b6 (define (up-split painter n) (if (= n 0) painter (let ((smaller (up-split painter (- n 1)))) (below painter (beside smaller smaller))))) Exercise 2.45 \u00b6 ; split returns a \"splitter\" like right-split and up-split ; with a primary direction d1 and secondary direction d2 (define (split d1 d2) (define (splitter painter n) (if (= n 0) painter (let ((smaller (splitter painter (- n 1)))) (d1 painter (d2 smaller smaller))))) splitter) (define right-split (split beside below)) (define up-split (split below beside)) Exercise 2.46 \u00b6 ; make-vect, xcor-vect, and ycor-vect implement a vector object. (define (make-vect x y) (cons x y)) (define (xcor-vect v) (car v)) (define (ycor-vect v) (cdr v)) ; add-vect, sub-vect, and scale-vect implement vector addition and scaling (define (add-vect v1 v2) (make-vect (+ (xcor-vect v1) (xcor-vect v2)) (+ (ycor-vect v1) (ycor-vect v2)))) (define (sub-vect v1 v2) (make-vect (- (xcor-vect v1) (xcor-vect v2)) (- (ycor-vect v1) (ycor-vect v2)))) (define (scale-vect s v) (make-vect (* s (xcor-vect v)) (* s (ycor-vect v)))) Exercise 2.47 \u00b6 (define (make-frame origin edge1 edge2) (list origin edge1 edge2)) (define (origin-frame f) (car f)) (define (edge1-frame f) (cadr f)) (define (edge2-frame f) (caddr f)) (define (make-frame origin edge1 edge2) (cons origin (cons edge1 edge2))) (define (origin-frame f) (car f)) (define (edge1-frame f) (cadr f)) (define (edge2-frame f) (cddr f)) Exercise 2.48 \u00b6 ; make-segment, start-segment, and end-segment are getters and setters ; for segments represented by two vectors. (define (make-segment v1 v2) (cons v1 v2)) (define (start-segment s) (car s)) (define (end-segment s) (cdr s)) Exercise 2.49 \u00b6 (define draw-outline (segments->painter (list (make-segment (make-vect 0.0 0.0) (make-vect 0.0 1.0)) (make-segment (make-vect 0.0 1.0) (make-vect 1.0 1.0)) (make-segment (make-vect 1.0 1.0) (make-vect 1.0 0.0)) (make-segment (make-vect 1.0 0.0) (make-vect 0.0 0.0))))) (define draw-diagonals (segments->painter (list (make-segment (make-vect 0.0 0.0) (make-vect 1.0 1.0)) (make-segment (make-vect 0.0 1.0) (make-vect 1.0 0.0))))) (define draw-varignon (segments->painter (list (make-segment (make-vect 0.5 0.0) (make-vect 1.0 0.5)) (make-segment (make-vect 1.0 0.5) (make-vect 0.5 1.0)) (make-segment (make-vect 0.5 1.0) (make-vect 0.0 0.5)) (make-segment (make-vect 0.0 0.5) (make-vect 0.5 0.0))))) The wave painter is too complex for me to represent here. Exercise 2.50 \u00b6 This requires a bit of spatial thinking to do. Just note that the base case has its origin at (0, 0), edge1's end at (1, 0), and edge2's end at (0, 1). (define (flip-horiz painter) (transform-painter painter (make-vect 1.0 0.0) (make-vect 0.0 0.0) (make-vect 1.0 1.0))) (define (rotate180 painter) (transform-painter painter (make-vect 1.0 1.0) (make-vect 0.0 1.0) (make-vect 1.0 0.0))) (define (rotate270 painter) (transform-painter painter (make-vect 0.0 1.0) (make-vect 0.0 0.0) (make-vect 1.0 1.0))) Exercise 2.51 \u00b6 (define (below painter1 painter2) (let ((split-point (make-vect 0.0 0.5))) (let ((paint-below (transform-painter painter1 (make-vect 0.0 0.0) (make-vect 1.0 0.0) split-point)) (paint-above (transform-painter painter2 split-point (make-vect 1.0 0.5) (make-vect 0.0 1.0)))) (lambda (frame) (paint-below frame) (paint-above frame))))) Alternatively, we could define below using beside with some rotation. The following is a visualization: (define (below painter1 painter2) (rotate90 (beside (rotate270 painter1) (rotate270 painter2)))) Exercise 2.52 \u00b6 As mentioned, wave is a bit too complex for me to represent here. The other problems can be solved though. corner-split but using only one copy of up-split and right-split instead of two: (define (corner-split painter n) (if (= n 0) painter (beside (below painter (up-split painter (- n 1))) (below (right-split painter (- n 1)) (corner-split painter (- n 1)))))) square-limit that displays rogers outwards (the painter should be horizontally flipped): (define (square-limit painter n) (let ((quarter (corner-split (flip-horiz painter) n))) (let ((half (beside (flip-horiz quarter) quarter))) (below (flip-vert half) half)))) 2.3 Symbolic Data \u00b6 Exercise 2.53 \u00b6 (list 'a 'b 'c) ; ==> (a b c) (list (list 'george)) ; ==> ((george)) (cdr '((x1 x2) (y1 y2))) ; ==> ((y1 y2)) (cadr '((x1 x2) (y1 y2))) ; ==> (y1 y2) (pair? (car '(a short list))) ; ==> #f (memq 'red '((red shoes) (blue socks))) ; ==> #f (memq 'red '(red shoes blue socks)) ; ==> (red shoes blue socks) Exercise 2.54 \u00b6 (define (equal? x y) (cond ((and (null? x) (null? y)) #t) ((or (null? x) (null? y)) #f) (else (and (eq? (car x) (car y)) (equal? (cdr x) (cdr y)))))) (equal? (list 'a 'b 'c) (list 'a 'b 'c)) ; #t (equal? (list 'a 'b 'c) (list 'a 'b 'c 'd)) ; #f Exercise 2.55 \u00b6 Consider that 'abracadabra provides the symbol abracadabra . It is interesting to note what ''abracadabra (representing the symbol of the symbol abracadabra ) yields: 'abracadabra ; ==> abracadabra ''abracadabra ; ==> (quote abracadabra) Consider then that 'a is actually a shorthand for (quote a) . Because of this, ''a is simply '(quote a) , which would yield (quote a) . (car ''abracadabra) ; (car '(quote abracadabra)) ; ==> quote Exercise 2.56 \u00b6 (define (make-exponentiation b e) (cond ((=number? e 0) b) ((=number? b 1) 1) ((and (number? b) (number? e)) (expt b e)) (else (list '** b e)))) (define (exponentiation? x) (and (pair? x) (eq? (car x) '**))) (define (base e) (cadr e)) (define (exponent e) (caddr e)) (define (deriv exp var) (cond ; other conditions go here ((exponentiation? exp) (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1))) (deriv (base exp) var))) (else (error \"unknown expression type: DERIV\" exp)))) Exercise 2.57 \u00b6 I had to weed out the constants from addends and separating their sum from the remaining elements. In addition, I had to change the definition of augend to allow for arbitrary-length expressions: ; make-sum creates a sum from variadic parameter addends. ; Sums first the constants and then creates this recursive definition ; such that (a+b+c) == (a+(b+c)). (define (make-sum . addends) ; sum-constantless sums addends recursively ; where addends has no constant. (define (sum-constantless addends) (if (= (length addends) 1) (car addends) (list '+ (car addends) (sum-constantless (cdr addends))))) (let ((constants-sum (accumulate + 0 (filter number? addends))) (remaining (filter (lambda (x) (not (number? x))) addends))) (cond ((null? remaining) constants-sum) ((= constants-sum 0) (sum-constantless remaining)) (else (list '+ constants-sum (sum-constantless remaining)))))) (define (sum? x) (and (pair? x) (eq? (car x) '+))) (define (addend s) (cadr s)) (define (augend s) (if (= (length (cddr s)) 1) (caddr s) (apply make-sum (cddr s)))) A similar process is going on with make-product ; make-product returns a product from a set of factors (define (make-product . factors) ; product-constantless multiplies recursively where factors has no constant (define (product-constantless factors) (if (= (length factors) 1) (car factors) (list '* (car factors) (product-constantless (cdr factors))))) (let ((constants-product (accumulate * 1 (filter number? factors))) (remaining (filter (lambda (x) (not (number? x))) factors))) (cond ((null? remaining) constants-product) ((= constants-product 0) 0) ((= constants-product 1) (product-constantless remaining)) (else (list '* constants-product (product-constantless remaining)))))) (define (product? x) (and (pair? x) (eq? (car x) '*))) (define (multiplier p) (cadr p)) (define (multiplicand p) (if (= (length (cddr p)) 1) (caddr p) (apply make-product (cddr p))))","title":"2"},{"location":"2-building-abstractions-with-data/#building-abstractions-with-data","text":"","title":"Building Abstractions with Data"},{"location":"2-building-abstractions-with-data/#21-introduction-to-data-abstraction","text":"","title":"2.1 Introduction to Data Abstraction"},{"location":"2-building-abstractions-with-data/#exercise-21","text":"(define (make-rat n d) (if (< d 0) (make-rat (- n) (- d)) (let ((g (abs (gcd n d)))) (cons (/ n g) (/ d g))))) Ensure that d is always positive, and make g always positive.","title":"Exercise 2.1"},{"location":"2-building-abstractions-with-data/#exercise-22","text":"; make-point creates a pair of x-y coordinates (define (make-point x y) (cons x y)) ; x-point and y-point return the x and y coordinates of a point p (define (x-point p) (car p)) (define (y-point p) (cdr p)) ; print-point prints details about a point (define (print-point p) (newline) (display \"(\") (display (x-point p)) (display \",\") (display (y-point p)) (display \")\")) ; make-segment creates a segment of two points (define (make-segment p1 p2) (cons p1 p2)) ; start-segment returns the first point of a segment (define (start-segment s) (car s)) ; end-segment returns the second point of a segment (define (end-segment s) (cdr s)) (define ss (make-segment (make-point 1 2) (make-point 3 4))) (print-point (start-segment ss)) ; ==> (1,2) (print-point (end-segment ss)) ; ==> (3,4)","title":"Exercise 2.2"},{"location":"2-building-abstractions-with-data/#exercise-23","text":"; make-rectangle creates a rectangle with c1, c2 as corners. ; Note that c1 and c2 can be anywhere in the plane, ; but the rectangle's segments will remain parallel to the x- and y-axes. ; For instance, c1=(1,4), c2=(4,2) creates a 3x2 rectangle. (define (make-rectangle c1 c2) (cons c1 c2)) ; width returns the width of the rectangle (define (width r) (abs (- (x-point (car r)) (x-point (cdr r))))) ; height returns the height of the rectangle (define (height r) (abs (- (y-point (car r)) (y-point (cdr r))))) ; perimeter computes for the perimeter of the rectangle. ; If the rectangle has zero width or height, it will return zero. (define (perimeter r) (if (or (= (width r) 0) (= (height r) 0)) 0 (* 2 (+ (width r) (height r))))) ; area returns the area of the rectangle. (define (area r) (* (width r) (height r))) All these functions can be tested as follows: (define rect (make-rectangle (make-point 1 4) (make-point 5 1))) (perimeter rect) ; ==> 14 (area rect) ; ==> 12","title":"Exercise 2.3"},{"location":"2-building-abstractions-with-data/#exercise-24","text":"(define (cons x y) (lambda (m) (m x y))) The procedure cons takes in two parameters x and y and returns a procedure that takes in a callable object m and returns the value (m x y) . (define (car z) (z (lambda (p q) p))) The procedure car takes in a callable object z , which in turn takes in a function that takes two callable values p and q , and then return q . This is actually a very clever way of \"implementing\" cons and car . The following is what goes on: (define pt (cons 2 3)) ; pt = (lambda (m) (m 2 3)) (car pt) ; (pt (lambda (p q) p)) ; ((lambda (m) (m 2 3)) (lambda (p q) p)) ; ((lambda (p q) p) 2 3) ; 2 Now, let us try constructing a cdr using the example for car . (define (cdr z) (z (lambda (p q) q))) (cdr pt) ; (pt (lambda (p q) q)) ; ((lambda (m) (m 2 3)) (lambda (p q) q)) ; ((lambda (p q) q) 2 3) ; 3","title":"Exercise 2.4"},{"location":"2-building-abstractions-with-data/#exercise-25","text":"This implementation requires repeatedly dividing the result by 2 or 3 to check how many 2's or 3's the value has. (define (cons x y) (* (expt 2 x) (expt 3 y))) (define (car p) (define (iter val res) (if (= (remainder val 2) 0) (iter (/ val 2) (+ res 1)) res)) (iter p 0)) (define (cdr p) (define (iter val res) (if (= (remainder val 3) 0) (iter (/ val 3) (+ res 1)) res)) (iter p 0)) (define pt (cons 3 4)) (car pt) ; ==> 3 (cdr pt) ; ==> 4","title":"Exercise 2.5"},{"location":"2-building-abstractions-with-data/#exercise-26","text":"(define zero (lambda (f) (lambda (x) x))) This defines zero as a function that takes in a function f and returns... a function that takes in x and returns the same x . (define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x))))) This defines add-1 as a procedure that takes in a callable value n and returns a function that takes in f that returns a function that takes in x and returns (f ((n f) x)) . Now that is mind-boggling... Let us try solving for (add-1 zero) : (add-1 zero) ; (add-1 (lambda (f) (lambda (x) x))) ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x)))) ; (lambda (f) (lambda (x) (f ((lambda (x) x) x)))) ; (lambda (f) (lambda (x) (f x))) Notice what happened here: (add-1 zero) takes in a function f and returns a function that takes in x and returns (f x) . Let us try to do that again. (add-1 (add-1 zero)) ; (add-1 (lambda (f) (lambda (x) (f x)))) ; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x)))) ; (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x)))) ; (lambda (f) (lambda (x) (f (f x)))) Another add-1 adds a call to f . Since (add-1 zero) is just one and (add-1 one) is two , we can easily give direct definitions for them: (define one (lambda (f) (lambda (x) (f x)))) (define two (lambda (f) (lambda (x) (f (f x))))) We can also make a + procedure which takes in two \"Church numerals\" and return their sum. But how do we do this is another thing... Suppose a is a Church numeral that represents the number A in Church encoding, i.e., (lambda (f) (lambda (x) (f (f ... (f x)))))) where f is callled A times. Similarly, let b be a Church numeral that represents B in Church encoding. Note (a f) and (b f) become (lambda (x) (f (f ... (f x)))) where f is composed A and B times respectively. We would want to get a result such that the number of calls for f is A+B . Simple: ((a f) ((b f) x)) . ((b f) x) returns (f (f ... (f x))) repeated B times, and that is wrapped around (a f) which calls f A times! (define (+ a b) (lambda (f) (lambda (x) ((a f) ((b f) x)))))","title":"Exercise 2.6"},{"location":"2-building-abstractions-with-data/#exercise-27","text":"The implementation of make-interval does not mandate a be less than b or vice versa. A check might be needed. (define (lower-bound x) (min (car x) (cdr x))) (define (upper-bound x) (max (car x) (cdr x)))","title":"Exercise 2.7"},{"location":"2-building-abstractions-with-data/#exercise-28","text":"The difference between the two ranges is the range between the smallest possible difference to the largest possible one. The smallest possible difference can be taken by minimizing the first number and maximizing the second, while the largest possible one can be taken by maximizing the second number and minimizing the first. Suppose that the first range is 5 to 8 and the second 1 to 2. The smallest possible difference is \\(5-2=3\\) while the largest one is \\(8-1=7\\) . Implementing it should be easy. ; sub-interval determines the interval for the difference between x and y (define (sub-interval x y) (make-interval (- (lower-bound x) (upper-bound y)) (- (upper-bound x) (lower-bound y)))) (define a (make-interval 5 8)) (define b (make-interval 1 2)) (sub-interval a b) ; 3 - 7","title":"Exercise 2.8"},{"location":"2-building-abstractions-with-data/#exercise-29","text":"Suppose \\(x=\\left[a,b\\right]\\) and \\(y=\\left[c,d\\right]\\) , and \\(W\\left(x\\right)\\) be the width function for \\(x\\) . Hence, \\(W\\left(x\\right)=\\frac{b-a}{2}\\) and \\(W\\left(y\\right)=\\frac{d-c}{2}\\) . We see that \\(x+y=[a+c,b+d]\\) and \\(x-y=[a-d,b-c]\\) . Astonishingly, \\(W\\left(x+y\\right)=W\\left(x-y\\right)=\\frac{\\left(b+d\\right)-\\left(a+c\\right)}{2}\\) , which subsequently equals \\(W\\left(x\\right)+W\\left(y\\right)\\) . For multiplication, \\(x\\times y = \\left[\\max\\left(ac,ad,bc,bd\\right), \\min\\left(ac,ad,bc,bd\\right)\\right]\\) , and so \\(W\\left(x\\times y\\right)\\) can become uncertain, hence there is no direct relationship between that and either of \\(W\\left(x\\right)\\) and \\(W\\left(y\\right)\\) . This goes the same with division, which is dependent on multiplication.","title":"Exercise 2.9"},{"location":"2-building-abstractions-with-data/#exercise-210","text":"(define (div-interval x y) ; spans-zero returns true if x spans zero by checking its signs (define (spans-zero x) (< (* (lower-bound x) (upper-bound x)) 0)) (if (spans-zero y) (error \"Dividend spans zero\") (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y)))))) (div-interval (make-interval 1 5) (make-interval 2 3)) ; returns something alright (div-interval (make-interval 1 5) (make-interval -2 3)) ; returns an error","title":"Exercise 2.10"},{"location":"2-building-abstractions-with-data/#exercise-211","text":"Suppose \\(S\\left(x\\right)\\) has the following property: \\[ S\\left(\\left[a,b\\right]\\right) = \\left\\{\\begin{array}{lr} -1 & \\text{if } a \\lt 0 \\text{ and } b \\lt 0\\\\ 0 & \\text{if } a \\lt 0 \\text{ and } b \\ge 0\\\\ 1 & \\text{if } a \\ge 0 \\text{ and } b \\ge 0 \\end{array}\\right. \\] With \\(x=\\left[a,b\\right]\\) and \\(y=\\left[c,d\\right]\\) , there are nine possible combinations for \\(x\\times y\\) determined by their \\(S\\) -values: \\[ % painstakingly transcribed using https://isaurssaurav.github.io/mathjax-table-generator/ \\begin{array} {|r|r|}\\hline _{S(x)} \\backslash ^{S(y)} & -1 & 0 & 1 \\\\ \\hline -1 & \\left[bd,ac\\right] & \\left[ad,ac\\right] & \\left[ad,bc\\right] \\\\ \\hline 0 & \\left[bc,ac\\right] & \\star & \\left[ad,bd\\right] \\\\ \\hline 1 & \\left[bc,ad\\right] & \\left[bc,bd\\right] & \\left[ac,bd\\right] \\\\ \\hline \\end{array} \\] These ranges have been computed by hand. Consider when \\(S\\left(x\\right)=1\\) and \\(S\\left(y\\right)=0\\) . In this case, the smallest possible number could be taken from \\(b\\) , the larger positive number in the range \\(x\\) , multiplied to \\(c\\) , the smallest negative number in \\(y\\) . Similarly, the largest possible number in the product could be taken from \\(b\\) multiplied to \\(d\\) , the largest positive number in \\(y\\) . (Try using the example \\(x=\\left[1,4\\right]\\) and \\(y=\\left[-2,3\\right]\\) .) The middle case, when both \\(x\\) and \\(y\\) span zero, is a bit stranger. The negative extrema \\(bc\\) and \\(ad\\) , and the positive extrema \\(ac\\) and \\(bd\\) , can be smaller or larger than the other. One has to perform the multiplication operations manually and check the largest value from there. The following is an implementation: ; mul-interval is an implementation of multiplying two intervals ; which uses two multiplication operations most of the time (define (mul-interval x y) ; neg be less than zero and nonneg be its complement (define (neg n) (< n 0)) (define (nonneg n) (>= n 0)) ; s be the s-value of a range (define (s x) (cond ((and (neg (lower-bound x)) (neg (upper-bound x))) -1) ((and (neg (lower-bound x)) (nonneg (upper-bound x))) 0) (else 1))) ; now for the great conditional (let ((a (lower-bound x)) (b (upper-bound x)) (c (lower-bound y)) (d (upper-bound y)) (sx (s x)) (sy (s y))) (cond ((and (= sx -1) (= sy -1)) (make-interval (* b d) (* a c))) ((and (= sx -1) (= sy 0)) (make-interval (* a d) (* a c))) ((and (= sx -1) (= sy 1)) (make-interval (* a d) (* b c))) ((and (= sx 0) (= sy -1)) (make-interval (* b c) (* a c))) ; skipping sx=0 and sy=0 and putting that as the else statement ((and (= sx 0) (= sy 1)) (make-interval (* a d) (* b d))) ((and (= sx 1) (= sy -1)) (make-interval (* b c) (* a d))) ((and (= sx 1) (= sy 0)) (make-interval (* b c) (* b d))) ((and (= sx 1) (= sy 1)) (make-interval (* a c) (* b d))) (else (let ((ac (* a c)) (ad (* a d)) (bc (* b c)) (bd (* b d))) (make-interval (min ad bc) (max ac bd))))))) Tests can be done by writing two intervals, multiplying them using this and the original implementation, and checking if they are equal. How much readability one is willing to trade off for performance is dependent on the one who writes the code.","title":"Exercise 2.11"},{"location":"2-building-abstractions-with-data/#exercise-212","text":"With some center \\(c\\) and a percent tolerance \\(p<1\\) , the range should be \\(\\left[c\\left(1-p\\right), c\\left(1+p\\right)\\right]\\) . ; make-center-percent makes an interval with center c and percent tolerance p. ; For example, if c=6.8 and p=10, the interval is between 6.8-(6.8*10%) and 6.8+(6.8*10%), ; which is 6.12 and 7.48. (define (make-center-percent c p) (make-interval (* c (- 1.0 (/ p 100.0))) (* c (+ 1.0 (/ p 100.0))))) (make-center-percent 6.8 10) ; 6.12 - 7.48","title":"Exercise 2.12"},{"location":"2-building-abstractions-with-data/#exercise-213","text":"Suppose there are two ranges: the first one having a center of \\(c_1\\) and percentage tolerance \\(p_1\\) , and the second having \\(c_2\\) and \\(p_2\\) . Henceforth, the two ranges are \\(\\left[{c_1}\\left(1-{p_1}\\right), {c_1}\\left(1+{p_1}\\right)\\right]\\) and \\(\\left[{c_2}\\left(1-{p_2}\\right), {c_2}\\left(1+{p_2}\\right)\\right]\\) . With the assumption that all numbers are positive, the product should have the range \\(\\left[{c_1}{c_2}\\left(1-{p_1}\\right)\\left(1-{p_2}\\right), {c_1}{c_2}\\left(1+{p_1}\\right)\\left(1+{p_2}\\right)\\right]\\) , which can be written as \\(\\left[{c_1}{c_2}\\left(1-\\left({p_1}+{p_2}\\right)+{p_1}{p_2}\\right), {c_1}{c_2}\\left(1+\\left({p_1}+{p_2}\\right)+{p_1}{p_2}\\right)\\right]\\) . If \\(p_1\\) and \\(p_2\\) are sufficiently small, \\({p_1}{p_2}\\) can be negligible, and the range is written as \\(\\left[{c_1}{c_2}\\left(1-\\left({p_1}+{p_2}\\right)\\right), {c_1}{c_2}\\left(1+\\left({p_1}+{p_2}\\right)\\right)\\right]\\) , which is a range with center \\({c_1}{c_2}\\) and percentage tolerance \\({p_1}+{p_2}\\) .","title":"Exercise 2.13"},{"location":"2-building-abstractions-with-data/#exercise-214","text":"Using a simple test, we see that the two procedures do output different values: (define r1 (make-center-percent 6800 10)) (define r2 (make-center-percent 3000 25)) (par1 r1 r2) ; (1226.179875333927 . 3351.2544802867387) (par2 r1 r2) ; (1645.1612903225807 . 2497.773820124666) Suppose \\(x=\\left[a,b\\right]\\) and \\(y=\\left[c,d\\right]\\) . We see that \\(x+y=\\left[a+c,b+d\\right]\\) and \\(x\\times y=\\left[ac, bd\\right]\\) . Let us consider, however, what div-interval does: (define (div-interval x y) (mul-interval x (make-interval (/ 1.0 (upper-bound y)) (/ 1.0 (lower-bound y))))) Or, in mathematical terms: \\[ \\begin{aligned} \\left[a,b\\right]\\div\\left[c,d\\right] &= \\left[a,b\\right]\\times \\left[\\frac{1}{d}, \\frac{1}{c}\\right] \\\\ &= \\left[\\frac{a}{d}, \\frac{b}{c}\\right] \\end{aligned} \\] Interestingly, if we have a range \\([a,b]\\) divided by itself: \\[ \\begin{aligned} \\left[a,b\\right]\\div\\left[a,b\\right] &= \\left[\\frac{a}{b}, \\frac{b}{a}\\right] \\end{aligned} \\] The current system does not have an identity principle. More on this later. From here, we can analyze the behaviors of par1 and par2 : \\[ \\begin{aligned} \\text{par1}\\left(x,y\\right) &= \\left(x\\times y\\right) \\div \\left(x+y\\right) \\\\ &= \\left[ac, bd\\right] \\div \\left[a+c, b+d\\right] \\\\ &= \\left[\\frac{ac}{b+d}, \\frac{bd}{a+c}\\right] \\end{aligned} \\] \\[ \\begin{aligned} \\text{par2}\\left(x,y\\right) &= \\left[1, 1\\right] \\div \\left(\\left(\\left[1,1\\right] \\div x\\right) + \\left(\\left[1,1\\right] \\div y\\right)\\right) \\\\ &= \\left[1,1\\right] \\div \\left(\\left(\\left[1,1\\right] \\div \\left[a,b\\right]\\right) + \\left(\\left[1,1\\right] \\div \\left[c,d\\right]\\right)\\right) \\\\ &= \\left[1,1\\right] \\div \\left(\\left[\\frac{1}{b}, \\frac{1}{a}\\right] + \\left[\\frac{1}{d}, \\frac{1}{c}\\right]\\right) \\\\ &= \\left[1,1\\right] \\div \\left(\\left[\\frac{1}{b} + \\frac{1}{d}, \\frac{1}{a} + \\frac{1}{c}\\right]\\right) \\\\ &= \\left[\\frac{1}{\\frac{1}{a} + \\frac{1}{c}} , \\frac{1}{\\frac{1}{b} + \\frac{1}{d}} \\right] \\\\ &= \\left[\\frac{ac}{a+c} , \\frac{bd}{b+d} \\right] \\end{aligned} \\]","title":"Exercise 2.14"},{"location":"2-building-abstractions-with-data/#exercise-215","text":"Let us consider the results of the previous exercise. We have to remember that \\(a<b\\) and \\(c<d\\) . Therefore, \\(a+c < b+d\\) , and this implies that \\(\\left[\\frac{ac}{b+d}, \\frac{bd}{a+c}\\right]\\) has a wider range than \\(\\left[\\frac{ac}{a+c} , \\frac{bd}{b+d} \\right]\\) because of the denominators of the parameters of the former. While it may be computationally cheaper to compute for \\({x}\\times{y}\\) in par1 , this will introduce a much larger range than par2 . This is perhaps the \"uncertainty\" that Eva Lu Ator is describing.","title":"Exercise 2.15"},{"location":"2-building-abstractions-with-data/#exercise-216","text":"Consider the lack of identity in div-interval . Because of this, \\(x + y \\div y \\neq x\\) . The two expressions should be equivalent, but they aren't. A principle of \"identity\" should be established where a program knows if an operation is applied to two \"same\" intervals, although doing so is a lot harder than it looks, and I can't say if it even were possible.","title":"Exercise 2.16"},{"location":"2-building-abstractions-with-data/#22-hierarchial-data-and-the-closure-property","text":"","title":"2.2 Hierarchial Data and the Closure Property"},{"location":"2-building-abstractions-with-data/#exercise-217","text":"; last-pair returns a pair which only contains the last element of a given list (define (last-pair items) (if (null? (cdr items)) items (last-pair (cdr items)))) (last-pair (list 23 72 149 34)) ; (34)","title":"Exercise 2.17"},{"location":"2-building-abstractions-with-data/#exercise-218","text":"Note that (cdr items) returns either a list or nil, and (car items) returns a single number. From here, how are we able to reverse a list? Of course, without using the built-in reverse . Remember that last-pair takes in the last \"pair\" of the list (its cdr is an empty value, so really it's a pair with only one element). This can be a very useful procedure. A reverse procedure would use last-pair to get the very last item, and a all-but-last procedure which returns the entire list without the very last element. (define (all-but-last items) (if (null? (cdr items)) () (cons (car items) (all-but-last (cdr items))))) (all-but-last (list 23 72 149 34)) ; (23 72 149) (define (reverse items) (if (null? items) items (cons (car (last-pair items)) (reverse (all-but-last items))))) (reverse (list 23 72 149 34)) ; (34 149 72 23)","title":"Exercise 2.18"},{"location":"2-building-abstractions-with-data/#exercise-219","text":"; first-denomination returns the first item on items (define (first-denomination items) (car items)) ; except-first-denomination returns items but the first one (define (except-first-denomination items) (cdr items)) ; no-more? checks if items is empty (define (no-more? items) (null? items)) ; using the previous procedures, as well as those in the book (cc 100 us-coins) ; 292 On whether order matters for coin-values , after every iteration, cc branches between when first-denomination has been chosen, and when it isn't and first-denomination is no longer available as an option. The order of the coins should not matter, since all permutations will be attempted. A simple demonstration of this, although definitely not solid proof, can be seen if us-coins were reversed: (cc 100 (reverse us-coins)) ; also 292","title":"Exercise 2.19"},{"location":"2-building-abstractions-with-data/#exercise-220","text":"(define (same-parity . items) (define (is-same-parity? x) (= (remainder (car items) 2) (remainder x 2))) (filter is-same-parity? items)) (same-parity 1 2 3 4 5 6 7) ; (1 3 5 7) (same-parity 2 3 4 5 6 7) ; (2 4 6) Wait, we aren't allowed to use filter yet? Okay then. (define (same-parity . items) (define (is-same-parity? x) (= (remainder (car items) 2) (remainder x 2))) ; recurse recurses through items with is-same-parity? and returns accum (define (recurse items accum) (cond ((null? items) accum) ((is-same-parity? (car items)) (recurse (cdr items) (cons (car items) accum))) (else (recurse (cdr items) accum)))) ; one call to reverse since accum appends to the left every time (reverse (recurse items ()))) (same-parity 1 2 3 4 5 6 7) ; (1 3 5 7) (same-parity 2 3 4 5 6 7) ; (2 4 6)","title":"Exercise 2.20"},{"location":"2-building-abstractions-with-data/#exercise-221","text":"(define (square-list items) (if (null? items) () ; \"nil\" (cons (square (car items)) (square-list (cdr items))))) (square-list (list 1 2 3 4)) (define (square-list items) (map square items)) (square-list (list 1 2 3 4))","title":"Exercise 2.21"},{"location":"2-building-abstractions-with-data/#exercise-222","text":"(define (square-list items) (define (iter things answer) (if (null? things) answer (iter (cdr things) (cons (square (car things)) answer)))) (iter items ())) (square-list (list 1 2 3 4)) ; (iter (list 1 2 3 4) ()) ; (iter (list 2 3 4) (cons (square 1) ())) ; (iter (list 2 3 4) (list 1)) ; (iter (list 3 4) (cons (square 2) (list 1))) ; (iter (list 3 4) (list 4 1)) ; (iter (list 4) (cons (square 3) (list 4 1))) ; (iter (list 4) (list 9 4 1)) ; (iter () (cons (square 4) (list 9 4 1))) ; (iter () (list 16 9 4 1)) ; (list 16 9 4 1) For every subsequent value taken from things , it is appended at the start of answer . The answers are stacked FILO. (define (square-list items) (define (iter things answer) (if (null? things) answer (iter (cdr things) (cons answer (square (car things)))))) (iter items ())) (square-list (list 1 2 3 4)) ; (iter (list 1 2 3 4) ()) ; (iter (list 2 3 4) (cons () (square 1))) ; (iter (list 2 3 4) (list () 1)) ; (iter (list 3 4) (cons (list () 1) (square 2))) ; (iter (list 3 4) (list (list () 1) 4)) ; (iter (list 4) (cons (list (list () 1) 4) (square 3))) ; (iter (list 4) (list (list (list () 1) 4) 9)) ; (iter () (cons (list (list (list () 1) 4) 9) (square 4))) ; (iter () (list (list (list (list () 1) 4) 9) 16)) ; (list (list (list (list () 1) 4) 9) 16) The problem here is that a list is cons 'd to a value, which should be the other way around. The final pair has a list in its first half, and a single value at its second. This will yield MIT Scheme to display something weird: 1 ]=> (square-list (list 1 2 3 4)) ;Value: ((((() . 1) . 4) . 9) . 16)","title":"Exercise 2.22"},{"location":"2-building-abstractions-with-data/#exercise-223","text":"(define (for-each f items) (define (execute-and-iterate f items) (f (car items)) (for-each f (cdr items))) (if (not (null? items)) (execute-and-iterate f items))) (for-each (lambda (x) (newline) (display x)) (list 57 321 88)) ; 57 ; 321 ; 88 ; returns unspecified value","title":"Exercise 2.23"},{"location":"2-building-abstractions-with-data/#exercise-224","text":"1 ]=> (list 1 (list 2 (list 3 4))) ;Value: (1 (2 (3 4))) This looks like an interesting list. Let us graph it, then. Notice, that this graph represents three lists, each of length 2. This is different from (list 1 2 3 4) , which would return a single list of length 4.","title":"Exercise 2.24"},{"location":"2-building-abstractions-with-data/#exercise-225","text":"(car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9)))))) ; 7 (car (car (list (list 7)))) ; 7 (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))))))))))) ; 7","title":"Exercise 2.25"},{"location":"2-building-abstractions-with-data/#exercise-226","text":"(define x (list 1 2 3)) (define y (list 4 5 6)) ; append appends two lists and combines their items (append x y) ; (1 2 3 4 5 6) ; cons creates a cons pair of two items. Note that y is \"linked\" to the result (cons x y) ; ((1 2 3) 4 5 6) ; list creates a list of the items it is provided with (list x y) ; ((1 2 3) (4 5 6))","title":"Exercise 2.26"},{"location":"2-building-abstractions-with-data/#exercise-227","text":"This is quite an interesting one. A reversal must also be done not only to the list in question, but to the items of the items if they do exist. (define (all-but-last items) (if (null? (cdr items)) () (cons (car items) (all-but-last (cdr items))))) (all-but-last (list 23 72 149 34)) ; (23 72 149) ; deep-reverse reverses items and its subitems (define (deep-reverse items) (cond ((null? items) items) ((not (list? items)) items) (else (cons (deep-reverse (car (last-pair items))) (deep-reverse (all-but-last items)))))) (define x (list (list 1 2) (list 3 4))) (reverse x) ; ((3 4) (1 2)) (deep-reverse x) ; ((4 3) (2 1))","title":"Exercise 2.27"},{"location":"2-building-abstractions-with-data/#exercise-228","text":"; fringe takes in items and returns a single flattened list (define (fringe items) (cond ((null? items) items) ((not (list? items)) (list items)) (else (append (fringe (car items)) (fringe (cdr items)))))) (define x (list (list 1 2) (list 3 4))) (fringe x) ; (1 2 3 4) (fringe (list x x)) ; (1 2 3 4 1 2 3 4)","title":"Exercise 2.28"},{"location":"2-building-abstractions-with-data/#exercise-229","text":"The following are the selectors for the mobile and branch structures defined by make-mobile and make-branch : ; left-branch returns the left branch of a mobile (define (left-branch mobile) (car mobile)) ; right-branch returns the right branch of a mobile (define (right-branch mobile) (car (cdr mobile))) ; branch-length returns the length of a branch (define (branch-length branch) (car branch)) ; branch-structure returns the structure attached to the branch (define (branch-structure branch) (car (cdr branch))) The following is an implementation for total-weight : ; total-weight returns the total weight of a mobile. Returns itself if mobile is a number. (define (total-weight mobile) (if (pair? mobile) ; i.e., mobile is represented by a pair i.e., it *is* a mobile (+ (total-weight (branch-structure (left-branch mobile))) (total-weight (branch-structure (right-branch mobile)))) mobile)) Why I used pair? instead of list? is such that, in a later problem, the mobile and branch structures will be represented by cons instead of list . All cons are list s but not the other way around! The following is an implementation for balanced? : ; torque returns the torque of a branch (define (torque branch) (* (branch-length branch) (total-weight (branch-structure branch)))) ; balanced? checks if a mobile is balanced. Returns true if mobile is a number (define (balanced? mobile) (if (not (pair? mobile)) #t (= (torque (left-branch mobile)) (torque (right-branch mobile))))) Going to the fourth problem, by doing this, we would only need to change (car (cdr ...)) to (cdr ...) : ; left-branch returns the left branch of a mobile (define (left-branch mobile) (car mobile)) ; right-branch returns the right branch of a mobile (define (right-branch mobile) (cdr mobile)) ; branch-length returns the length of a branch (define (branch-length branch) (car branch)) ; branch-structure returns the structure attached to the branch (define (branch-structure branch) (cdr branch))","title":"Exercise 2.29"},{"location":"2-building-abstractions-with-data/#exercise-230","text":"; square-tree squares a tree (define (square-tree tree) (map (lambda (sub-tree) (if (pair? sub-tree) (square-tree sub-tree) (square sub-tree))) tree)) (square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))) ; ==> (1 (4 (9 16) 25) (36 49))","title":"Exercise 2.30"},{"location":"2-building-abstractions-with-data/#exercise-231","text":"; tree-map maps f to tree such that element -> (f element) (define (tree-map f tree) (map (lambda (sub-tree) (if (pair? sub-tree) (tree-map f sub-tree) (f sub-tree))) tree))","title":"Exercise 2.31"},{"location":"2-building-abstractions-with-data/#exercise-232","text":"For each element e which is an element of S , all subsets of S will either have e , or not. (define (subsets s) (if (null? s) (list ()) (let ((rest (subsets (cdr s)))) (append rest (map (lambda (subset) (cons (car s) subset)) rest))))) (subsets (list 1 2 3)) ; ==> (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)) The return value is the combination of rest , which are the subsets of cdr s , and (map (lambda (subset) (cons (car s) subset)) rest) , which is car s appended to each value of rest . Every element in the return value will either have car s or not.","title":"Exercise 2.32"},{"location":"2-building-abstractions-with-data/#exercise-233","text":"map is defined as accumulating a list using sequence by repeatedly applying (p elem) to every elem : (define (map p sequence) (accumulate (lambda (x y) (cons (p x) y)) () sequence)) append performs a cons for every elem of seq1 into seq2 : (define (append seq1 seq2) (accumulate cons seq2 seq1)) length iterates the value by 1 every time an element is encountered: (define (length sequence) (accumulate (lambda (_ y) (+ y 1)) 0 sequence))","title":"Exercise 2.33"},{"location":"2-building-abstractions-with-data/#exercise-234","text":"In the problem statement, the keyword higher-terms was used, which was a bit of a misnomer and threw me off for a while. ; horner-eval performs a Horner evaluation on coefficient-sequence with a particular x. (define (horner-eval x coefficient-sequence) (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* higher-terms x))) 0 coefficient-sequence)) (horner-eval 2 (list 1 3 0 5 0 1)) ; ==> 79","title":"Exercise 2.34"},{"location":"2-building-abstractions-with-data/#exercise-235","text":"; count-leaves counts the number of leaves in t (define (count-leaves t) (accumulate (lambda (current-value total) (+ total (length current-value))) 0 (map enumerate-tree t)))","title":"Exercise 2.35"},{"location":"2-building-abstractions-with-data/#exercise-236","text":"; accumulate-n takes in a sequence of sequences and accumulates using op and init. (define (accumulate-n op init seqs) (if (null? (car seqs)) () (cons (accumulate op init (map car seqs)) (accumulate-n op init (map cdr seqs))))) (define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12))) (accumulate-n + 0 s) ; ==> (22 26 30) Inside the cons statement, we combine two values: the accumulated result of the first items of seqs , and the results of the remaining items of seqs . To get the first items of seqs , (map car seqs) is used, where every sequence is mapped to car thus returning the first item. Similarly, to get the remaining items of seqs , (map cdr seqs) is used.","title":"Exercise 2.36"},{"location":"2-building-abstractions-with-data/#exercise-237","text":"; matrix-*-vector performs a multiplication between a matrix and a vector ; and returns a vector (define (matrix-*-vector m v) (map (lambda (row) (dot-product row v)) m)) ; Example from https://mathinsight.org/matrix_vector_multiplication (matrix-*-vector (list (list 1 -1 2) (list 0 -3 1)) (list 2 1 0)) ; (1 -3) ; transpose transposes a matrix (define (transpose mat) (accumulate-n cons ; used to append each element for every column in the matrix () mat)) ; Example from https://en.wikipedia.org/wiki/Transpose (transpose (list (list 1 2) (list 3 4) (list 5 6))) ; ((1 3 5) (2 4 6)) ; matrix-*-matrix performs a multiplication between two matrices (define (matrix-*-matrix m n) (let ((cols (transpose n))) (map (lambda (row) (matrix-*-vector cols row)) m))) ; Example from https://mathinsight.org/matrix_vector_multiplication (matrix-*-matrix (list (list 0 4 -2) (list -4 -3 0)) (list (list 0 1) (list 1 -1) (list 2 3))) ; ((0 -10) (-3 -1))","title":"Exercise 2.37"},{"location":"2-building-abstractions-with-data/#exercise-238","text":"For the first pair of statements: (fold-right / 1 (list 1 2 3)) ; (/ 1 (fold-right / 1 (list 2 3))) ; (/ 1 (/ 2 (fold-right / 1 (list 3)))) ; (/ 1 (/ 2 (/ 3 (fold-right / 1 ())))) ; (/ 1 (/ 2 (/ 3 1))) ; (/ 1 (/ 2 3)) ; (/ 1 (0.667)) ; using floating-points instead of rationals for this showcasing ; ==> 1.5 (fold-left / 1 (list 1 2 3)) ; (iter 1 (list 1 2 3)) ; (iter (/ 1 1) (list 2 3)) ; (iter 1 (list 2 3)) ; (iter (/ 1 2) (list 3)) ; (iter 0.5 (list 3)) ; (iter (/ 0.5 3) ()) ; (iter 0.167 ()) ; ==> 0.167 The first statement was \\(1 \\div \\left(2 \\div 3\\right)\\) , while the second one was \\(\\left(1 \\div 2\\right) \\div 3\\) For the second pair of statements: (fold-right list () (list 1 2 3)) ; (list 1 (fold-right list () (list 2 3))) ; (list 1 (list 2 (fold-right list () (list 3)))) ; (list 1 (list 2 (list 3 (fold-right list () ())))) ; (list 1 (list 2 (list 3 ()))) ; ==> (1 (2 (3 ()))) (fold-left list () (list 1 2 3)) ; (iter () (list 1 2 3)) ; (iter (list () 1) (list 2 3)) ; (iter (list (list () 1) 2) (list 3)) ; (iter (list (list (list () 1) 2) 3) ()) ; ==> (((() 1) 2) 3) For fold-left and fold-right to have the same result, (op a b) must equal (op b a) , that is, the order of operations ought not matter.","title":"Exercise 2.38"},{"location":"2-building-abstractions-with-data/#exercise-239","text":"(define (reverse sequence) (fold-right (lambda (x y) (append y (list x))) () sequence)) (reverse (list 1 2 3 4)) ; (4 3 2 1) (define (reverse sequence) (fold-left (lambda (x y) (cons y x)) () sequence)) (reverse (list 1 2 3 4)) ; (4 3 2 1)","title":"Exercise 2.39"},{"location":"2-building-abstractions-with-data/#exercise-240","text":"; unique-pairs generates a sequence of (i,j) with 1<=j<i<=n. (define (unique-pairs n) (flatmap (lambda (i) (map (lambda (j) (list i j)) (enumerate-interval 1 (- i 1)))) (enumerate-interval 1 n))) (unique-pairs 6) ; prime-sum-pairs generates a sequence of (i,j) from unique-pairs ; such that i+j is prime (define (prime-sum-pairs n) ; sum gets the sum of the values of a pair (define (sum p) (+ (car p) (cadr p))) (map (lambda (p) (append p (list (sum p)))) (filter (lambda (p) (prime? (sum p))) (unique-pairs n)))) (prime-sum-pairs 6)","title":"Exercise 2.40"},{"location":"2-building-abstractions-with-data/#exercise-241","text":"; triples-with-sum returns a sequence of ordered pairs (i,j,k) ; such that i+j+k=s (define (triples-with-sum s) (flatmap (lambda (i) (map (lambda (j) (list i j (- s i j))) (enumerate-interval 1 (- s i 1)))) (enumerate-interval 1 s))) (triples-with-sum 6) ; ((1 1 4) (1 2 3) (1 3 2) (1 4 1) (2 1 3) (2 2 2) (2 3 1) (3 1 2) (3 2 1) (4 1 1))","title":"Exercise 2.41"},{"location":"2-building-abstractions-with-data/#exercise-242","text":"The convention I used for a position in the board would be a pair made using cons . ; a position is represented using a cons where col, row are from 1 to n ; where the queens are arranged in an nxn grid (define (position col row) (cons col row)) ; col and row get the col and row of a position (define (col position) (car position)) (define (row position) (cdr position)) ; adjoin-position adjoins a new row-column position to a set of positions (define (adjoin-position new-row k rest-of-queens) (append rest-of-queens (list (position k new-row)))) With regards to checking safety, same-row? , same-col? and same-diag? are written to check if two positions fall in the same row, column, or diagonal. I had to check for every pair of positions (pos, key) where pos is positions except key , and key is the only position which has a column k . ; empty-board represents an empty set of positions (define empty-board ()) ; safe? determines whether the queen in the k'th column is safe w/ respect to others (define (safe? k positions) ; suppose there are two positions a and b. ; let's do some checks... ; same-row? returns true if a, b have the same row (define (same-row? a b) (= (row a) (row b))) ; same-col? returns true if a, b have the same column (define (same-col? a b) (= (col a) (col b))) ; same-diag? returns true if a, b can be found diagonally (define (same-diag? a b) (= (abs (- (row a) (row b))) (abs (- (col a) (col b))))) ; relatively-safe? returns #t if a, b share neither row nor col nor diag (define (relatively-safe? a b) (and (not (same-row? a b)) (not (same-col? a b)) (not (same-diag? a b)))) ; positions-but returns positions but itself (define (positions-but itself) (filter (lambda (pos) (not (and (= (row pos) (row itself)) (= (col pos) (col itself))))) positions)) ; key-position returns the position whose column is k *and return the first value* (define (key-position k) (car (filter (lambda (pos) (= (col pos) k)) positions))) ; all-true makes sure all of elems are equal to true (define (all-true elems) (accumulate (lambda (acc cnt) (if (not cnt) ; cnt == #f #f acc)) ; if acc were #f then cnt becomes #f and it stays #f #t elems)) (let ((key (key-position k))) (all-true (map (lambda (pos) (relatively-safe? key pos)) (positions-but key))))) Running (queens 8) yields all 92 potential solutions to the Eight Queens puzzle. ; queens returns all possible solutions to the eight-queens puzzle (define (queens board-size) ; queen-cols list the possible solutions to eight-queens on a kxk grid (define (queen-cols k) (if (= k 0) (list empty-board) (filter (lambda (positions) (safe? k positions)) (flatmap (lambda (rest-of-queens) (map (lambda (new-row) (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size))) (queen-cols (- k 1)))))) (queen-cols board-size)) (queens 8) ; ((1 . 1) (2 . 5) (3 . 8) (4 . 6) (5 . 3) (6 . 7) (7 . 2) (8 . 4)) ; ((1 . 1) (2 . 6) (3 . 8) (4 . 3) (5 . 7) (6 . 4) (7 . 2) (8 . 5)) ; ((1 . 1) (2 . 7) (3 . 4) (4 . 6) (5 . 8) (6 . 2) (7 . 5) (8 . 3)) ; ((1 . 1) (2 . 7) (3 . 5) (4 . 8) (5 . 2) (6 . 4) (7 . 6) (8 . 3)) ; ((1 . 2) (2 . 4) (3 . 6) (4 . 8) (5 . 3) (6 . 1) (7 . 7) (8 . 5)) ; ((1 . 2) (2 . 5) (3 . 7) (4 . 1) (5 . 3) (6 . 8) (7 . 6) (8 . 4)) ; ((1 . 2) (2 . 5) (3 . 7) (4 . 4) (5 . 1) (6 . 8) (7 . 6) (8 . 3)) ; ((1 . 2) (2 . 6) (3 . 1) (4 . 7) (5 . 4) (6 . 8) (7 . 3) (8 . 5)) ; ((1 . 2) (2 . 6) (3 . 8) (4 . 3) (5 . 1) (6 . 4) (7 . 7) (8 . 5)) ; ((1 . 2) (2 . 7) (3 . 3) (4 . 6) (5 . 8) (6 . 5) (7 . 1) (8 . 4)) ; ((1 . 2) (2 . 7) (3 . 5) (4 . 8) (5 . 1) (6 . 4) (7 . 6) (8 . 3)) ; ((1 . 2) (2 . 8) (3 . 6) (4 . 1) (5 . 3) (6 . 5) (7 . 7) (8 . 4)) ; ((1 . 3) (2 . 1) (3 . 7) (4 . 5) (5 . 8) (6 . 2) (7 . 4) (8 . 6)) ; ((1 . 3) (2 . 5) (3 . 2) (4 . 8) (5 . 1) (6 . 7) (7 . 4) (8 . 6)) ; ((1 . 3) (2 . 5) (3 . 2) (4 . 8) (5 . 6) (6 . 4) (7 . 7) (8 . 1)) ; ((1 . 3) (2 . 5) (3 . 7) (4 . 1) (5 . 4) (6 . 2) (7 . 8) (8 . 6)) ; ((1 . 3) (2 . 5) (3 . 8) (4 . 4) (5 . 1) (6 . 7) (7 . 2) (8 . 6)) ; ((1 . 3) (2 . 6) (3 . 2) (4 . 5) (5 . 8) (6 . 1) (7 . 7) (8 . 4)) ; ((1 . 3) (2 . 6) (3 . 2) (4 . 7) (5 . 1) (6 . 4) (7 . 8) (8 . 5)) ; ((1 . 3) (2 . 6) (3 . 2) (4 . 7) (5 . 5) (6 . 1) (7 . 8) (8 . 4)) ; ((1 . 3) (2 . 6) (3 . 4) (4 . 1) (5 . 8) (6 . 5) (7 . 7) (8 . 2)) ; ((1 . 3) (2 . 6) (3 . 4) (4 . 2) (5 . 8) (6 . 5) (7 . 7) (8 . 1)) ; ((1 . 3) (2 . 6) (3 . 8) (4 . 1) (5 . 4) (6 . 7) (7 . 5) (8 . 2)) ; ((1 . 3) (2 . 6) (3 . 8) (4 . 1) (5 . 5) (6 . 7) (7 . 2) (8 . 4)) ; ((1 . 3) (2 . 6) (3 . 8) (4 . 2) (5 . 4) (6 . 1) (7 . 7) (8 . 5)) ; ((1 . 3) (2 . 7) (3 . 2) (4 . 8) (5 . 5) (6 . 1) (7 . 4) (8 . 6)) ; ((1 . 3) (2 . 7) (3 . 2) (4 . 8) (5 . 6) (6 . 4) (7 . 1) (8 . 5)) ; ((1 . 3) (2 . 8) (3 . 4) (4 . 7) (5 . 1) (6 . 6) (7 . 2) (8 . 5)) ; ((1 . 4) (2 . 1) (3 . 5) (4 . 8) (5 . 2) (6 . 7) (7 . 3) (8 . 6)) ; ((1 . 4) (2 . 1) (3 . 5) (4 . 8) (5 . 6) (6 . 3) (7 . 7) (8 . 2)) ; ((1 . 4) (2 . 2) (3 . 5) (4 . 8) (5 . 6) (6 . 1) (7 . 3) (8 . 7)) ; ((1 . 4) (2 . 2) (3 . 7) (4 . 3) (5 . 6) (6 . 8) (7 . 1) (8 . 5)) ; ((1 . 4) (2 . 2) (3 . 7) (4 . 3) (5 . 6) (6 . 8) (7 . 5) (8 . 1)) ; ((1 . 4) (2 . 2) (3 . 7) (4 . 5) (5 . 1) (6 . 8) (7 . 6) (8 . 3)) ; ((1 . 4) (2 . 2) (3 . 8) (4 . 5) (5 . 7) (6 . 1) (7 . 3) (8 . 6)) ; ((1 . 4) (2 . 2) (3 . 8) (4 . 6) (5 . 1) (6 . 3) (7 . 5) (8 . 7)) ; ((1 . 4) (2 . 6) (3 . 1) (4 . 5) (5 . 2) (6 . 8) (7 . 3) (8 . 7)) ; ((1 . 4) (2 . 6) (3 . 8) (4 . 2) (5 . 7) (6 . 1) (7 . 3) (8 . 5)) ; ((1 . 4) (2 . 6) (3 . 8) (4 . 3) (5 . 1) (6 . 7) (7 . 5) (8 . 2)) ; ((1 . 4) (2 . 7) (3 . 1) (4 . 8) (5 . 5) (6 . 2) (7 . 6) (8 . 3)) ; ((1 . 4) (2 . 7) (3 . 3) (4 . 8) (5 . 2) (6 . 5) (7 . 1) (8 . 6)) ; ((1 . 4) (2 . 7) (3 . 5) (4 . 2) (5 . 6) (6 . 1) (7 . 3) (8 . 8)) ; ((1 . 4) (2 . 7) (3 . 5) (4 . 3) (5 . 1) (6 . 6) (7 . 8) (8 . 2)) ; ((1 . 4) (2 . 8) (3 . 1) (4 . 3) (5 . 6) (6 . 2) (7 . 7) (8 . 5)) ; ((1 . 4) (2 . 8) (3 . 1) (4 . 5) (5 . 7) (6 . 2) (7 . 6) (8 . 3)) ; ((1 . 4) (2 . 8) (3 . 5) (4 . 3) (5 . 1) (6 . 7) (7 . 2) (8 . 6)) ; ((1 . 5) (2 . 1) (3 . 4) (4 . 6) (5 . 8) (6 . 2) (7 . 7) (8 . 3)) ; ((1 . 5) (2 . 1) (3 . 8) (4 . 4) (5 . 2) (6 . 7) (7 . 3) (8 . 6)) ; ((1 . 5) (2 . 1) (3 . 8) (4 . 6) (5 . 3) (6 . 7) (7 . 2) (8 . 4)) ; ((1 . 5) (2 . 2) (3 . 4) (4 . 6) (5 . 8) (6 . 3) (7 . 1) (8 . 7)) ; ((1 . 5) (2 . 2) (3 . 4) (4 . 7) (5 . 3) (6 . 8) (7 . 6) (8 . 1)) ; ((1 . 5) (2 . 2) (3 . 6) (4 . 1) (5 . 7) (6 . 4) (7 . 8) (8 . 3)) ; ((1 . 5) (2 . 2) (3 . 8) (4 . 1) (5 . 4) (6 . 7) (7 . 3) (8 . 6)) ; ((1 . 5) (2 . 3) (3 . 1) (4 . 6) (5 . 8) (6 . 2) (7 . 4) (8 . 7)) ; ((1 . 5) (2 . 3) (3 . 1) (4 . 7) (5 . 2) (6 . 8) (7 . 6) (8 . 4)) ; ((1 . 5) (2 . 3) (3 . 8) (4 . 4) (5 . 7) (6 . 1) (7 . 6) (8 . 2)) ; ((1 . 5) (2 . 7) (3 . 1) (4 . 3) (5 . 8) (6 . 6) (7 . 4) (8 . 2)) ; ((1 . 5) (2 . 7) (3 . 1) (4 . 4) (5 . 2) (6 . 8) (7 . 6) (8 . 3)) ; ((1 . 5) (2 . 7) (3 . 2) (4 . 4) (5 . 8) (6 . 1) (7 . 3) (8 . 6)) ; ((1 . 5) (2 . 7) (3 . 2) (4 . 6) (5 . 3) (6 . 1) (7 . 4) (8 . 8)) ; ((1 . 5) (2 . 7) (3 . 2) (4 . 6) (5 . 3) (6 . 1) (7 . 8) (8 . 4)) ; ((1 . 5) (2 . 7) (3 . 4) (4 . 1) (5 . 3) (6 . 8) (7 . 6) (8 . 2)) ; ((1 . 5) (2 . 8) (3 . 4) (4 . 1) (5 . 3) (6 . 6) (7 . 2) (8 . 7)) ; ((1 . 5) (2 . 8) (3 . 4) (4 . 1) (5 . 7) (6 . 2) (7 . 6) (8 . 3)) ; ((1 . 6) (2 . 1) (3 . 5) (4 . 2) (5 . 8) (6 . 3) (7 . 7) (8 . 4)) ; ((1 . 6) (2 . 2) (3 . 7) (4 . 1) (5 . 3) (6 . 5) (7 . 8) (8 . 4)) ; ((1 . 6) (2 . 2) (3 . 7) (4 . 1) (5 . 4) (6 . 8) (7 . 5) (8 . 3)) ; ((1 . 6) (2 . 3) (3 . 1) (4 . 7) (5 . 5) (6 . 8) (7 . 2) (8 . 4)) ; ((1 . 6) (2 . 3) (3 . 1) (4 . 8) (5 . 4) (6 . 2) (7 . 7) (8 . 5)) ; ((1 . 6) (2 . 3) (3 . 1) (4 . 8) (5 . 5) (6 . 2) (7 . 4) (8 . 7)) ; ((1 . 6) (2 . 3) (3 . 5) (4 . 7) (5 . 1) (6 . 4) (7 . 2) (8 . 8)) ; ((1 . 6) (2 . 3) (3 . 5) (4 . 8) (5 . 1) (6 . 4) (7 . 2) (8 . 7)) ; ((1 . 6) (2 . 3) (3 . 7) (4 . 2) (5 . 4) (6 . 8) (7 . 1) (8 . 5)) ; ((1 . 6) (2 . 3) (3 . 7) (4 . 2) (5 . 8) (6 . 5) (7 . 1) (8 . 4)) ; ((1 . 6) (2 . 3) (3 . 7) (4 . 4) (5 . 1) (6 . 8) (7 . 2) (8 . 5)) ; ((1 . 6) (2 . 4) (3 . 1) (4 . 5) (5 . 8) (6 . 2) (7 . 7) (8 . 3)) ; ((1 . 6) (2 . 4) (3 . 2) (4 . 8) (5 . 5) (6 . 7) (7 . 1) (8 . 3)) ; ((1 . 6) (2 . 4) (3 . 7) (4 . 1) (5 . 3) (6 . 5) (7 . 2) (8 . 8)) ; ((1 . 6) (2 . 4) (3 . 7) (4 . 1) (5 . 8) (6 . 2) (7 . 5) (8 . 3)) ; ((1 . 6) (2 . 8) (3 . 2) (4 . 4) (5 . 1) (6 . 7) (7 . 5) (8 . 3)) ; ((1 . 7) (2 . 1) (3 . 3) (4 . 8) (5 . 6) (6 . 4) (7 . 2) (8 . 5)) ; ((1 . 7) (2 . 2) (3 . 4) (4 . 1) (5 . 8) (6 . 5) (7 . 3) (8 . 6)) ; ((1 . 7) (2 . 2) (3 . 6) (4 . 3) (5 . 1) (6 . 4) (7 . 8) (8 . 5)) ; ((1 . 7) (2 . 3) (3 . 1) (4 . 6) (5 . 8) (6 . 5) (7 . 2) (8 . 4)) ; ((1 . 7) (2 . 3) (3 . 8) (4 . 2) (5 . 5) (6 . 1) (7 . 6) (8 . 4)) ; ((1 . 7) (2 . 4) (3 . 2) (4 . 5) (5 . 8) (6 . 1) (7 . 3) (8 . 6)) ; ((1 . 7) (2 . 4) (3 . 2) (4 . 8) (5 . 6) (6 . 1) (7 . 3) (8 . 5)) ; ((1 . 7) (2 . 5) (3 . 3) (4 . 1) (5 . 6) (6 . 8) (7 . 2) (8 . 4)) ; ((1 . 8) (2 . 2) (3 . 4) (4 . 1) (5 . 7) (6 . 5) (7 . 3) (8 . 6)) ; ((1 . 8) (2 . 2) (3 . 5) (4 . 3) (5 . 1) (6 . 7) (7 . 4) (8 . 6)) ; ((1 . 8) (2 . 3) (3 . 1) (4 . 6) (5 . 2) (6 . 5) (7 . 7) (8 . 4)) ; ((1 . 8) (2 . 4) (3 . 1) (4 . 3) (5 . 6) (6 . 2) (7 . 7) (8 . 5))","title":"Exercise 2.42"},{"location":"2-building-abstractions-with-data/#exercise-243","text":"Let us first consider our original program: (flatmap (lambda (rest-of-queens) (map (lambda (new-row) (adjoin-position new-row k rest-of-queens)) (enumerate-interval 1 board-size))) (queen-cols (- k 1)))) and let us look at Louis Reasoner's code: (flatmap (lambda (new-row) (map (lambda (rest-of-queens) (adjoin-position new-row k rest-of-queens)) (queen-cols (- k 1)))) (enumerate-interval 1 board-size)) We know that the order of operations have been swapped, but why does the second block of code run much, much slower than the first one? It took almost instantly to run (queens 6) originally, whereas it took around 4 seconds with the mistake. Consider that, at the first block of code, that queen-cols should only be called once, as a parameter of flatmap . However, at the second block of code, queen-cols is called board-size number of times since, for every value of (enumerate-interval 1 board-size) , the value is passed onto the lambda which calls queen-cols every time that happpens. It took around 91 milliseconds to run the Eight Queens problem but it took 70434 milliseconds to run Louis's version. I can't explain the discrepancy well but this blogpost by Werner de Groot can.","title":"Exercise 2.43"},{"location":"2-building-abstractions-with-data/#exercise-244","text":"(define (up-split painter n) (if (= n 0) painter (let ((smaller (up-split painter (- n 1)))) (below painter (beside smaller smaller)))))","title":"Exercise 2.44"},{"location":"2-building-abstractions-with-data/#exercise-245","text":"; split returns a \"splitter\" like right-split and up-split ; with a primary direction d1 and secondary direction d2 (define (split d1 d2) (define (splitter painter n) (if (= n 0) painter (let ((smaller (splitter painter (- n 1)))) (d1 painter (d2 smaller smaller))))) splitter) (define right-split (split beside below)) (define up-split (split below beside))","title":"Exercise 2.45"},{"location":"2-building-abstractions-with-data/#exercise-246","text":"; make-vect, xcor-vect, and ycor-vect implement a vector object. (define (make-vect x y) (cons x y)) (define (xcor-vect v) (car v)) (define (ycor-vect v) (cdr v)) ; add-vect, sub-vect, and scale-vect implement vector addition and scaling (define (add-vect v1 v2) (make-vect (+ (xcor-vect v1) (xcor-vect v2)) (+ (ycor-vect v1) (ycor-vect v2)))) (define (sub-vect v1 v2) (make-vect (- (xcor-vect v1) (xcor-vect v2)) (- (ycor-vect v1) (ycor-vect v2)))) (define (scale-vect s v) (make-vect (* s (xcor-vect v)) (* s (ycor-vect v))))","title":"Exercise 2.46"},{"location":"2-building-abstractions-with-data/#exercise-247","text":"(define (make-frame origin edge1 edge2) (list origin edge1 edge2)) (define (origin-frame f) (car f)) (define (edge1-frame f) (cadr f)) (define (edge2-frame f) (caddr f)) (define (make-frame origin edge1 edge2) (cons origin (cons edge1 edge2))) (define (origin-frame f) (car f)) (define (edge1-frame f) (cadr f)) (define (edge2-frame f) (cddr f))","title":"Exercise 2.47"},{"location":"2-building-abstractions-with-data/#exercise-248","text":"; make-segment, start-segment, and end-segment are getters and setters ; for segments represented by two vectors. (define (make-segment v1 v2) (cons v1 v2)) (define (start-segment s) (car s)) (define (end-segment s) (cdr s))","title":"Exercise 2.48"},{"location":"2-building-abstractions-with-data/#exercise-249","text":"(define draw-outline (segments->painter (list (make-segment (make-vect 0.0 0.0) (make-vect 0.0 1.0)) (make-segment (make-vect 0.0 1.0) (make-vect 1.0 1.0)) (make-segment (make-vect 1.0 1.0) (make-vect 1.0 0.0)) (make-segment (make-vect 1.0 0.0) (make-vect 0.0 0.0))))) (define draw-diagonals (segments->painter (list (make-segment (make-vect 0.0 0.0) (make-vect 1.0 1.0)) (make-segment (make-vect 0.0 1.0) (make-vect 1.0 0.0))))) (define draw-varignon (segments->painter (list (make-segment (make-vect 0.5 0.0) (make-vect 1.0 0.5)) (make-segment (make-vect 1.0 0.5) (make-vect 0.5 1.0)) (make-segment (make-vect 0.5 1.0) (make-vect 0.0 0.5)) (make-segment (make-vect 0.0 0.5) (make-vect 0.5 0.0))))) The wave painter is too complex for me to represent here.","title":"Exercise 2.49"},{"location":"2-building-abstractions-with-data/#exercise-250","text":"This requires a bit of spatial thinking to do. Just note that the base case has its origin at (0, 0), edge1's end at (1, 0), and edge2's end at (0, 1). (define (flip-horiz painter) (transform-painter painter (make-vect 1.0 0.0) (make-vect 0.0 0.0) (make-vect 1.0 1.0))) (define (rotate180 painter) (transform-painter painter (make-vect 1.0 1.0) (make-vect 0.0 1.0) (make-vect 1.0 0.0))) (define (rotate270 painter) (transform-painter painter (make-vect 0.0 1.0) (make-vect 0.0 0.0) (make-vect 1.0 1.0)))","title":"Exercise 2.50"},{"location":"2-building-abstractions-with-data/#exercise-251","text":"(define (below painter1 painter2) (let ((split-point (make-vect 0.0 0.5))) (let ((paint-below (transform-painter painter1 (make-vect 0.0 0.0) (make-vect 1.0 0.0) split-point)) (paint-above (transform-painter painter2 split-point (make-vect 1.0 0.5) (make-vect 0.0 1.0)))) (lambda (frame) (paint-below frame) (paint-above frame))))) Alternatively, we could define below using beside with some rotation. The following is a visualization: (define (below painter1 painter2) (rotate90 (beside (rotate270 painter1) (rotate270 painter2))))","title":"Exercise 2.51"},{"location":"2-building-abstractions-with-data/#exercise-252","text":"As mentioned, wave is a bit too complex for me to represent here. The other problems can be solved though. corner-split but using only one copy of up-split and right-split instead of two: (define (corner-split painter n) (if (= n 0) painter (beside (below painter (up-split painter (- n 1))) (below (right-split painter (- n 1)) (corner-split painter (- n 1)))))) square-limit that displays rogers outwards (the painter should be horizontally flipped): (define (square-limit painter n) (let ((quarter (corner-split (flip-horiz painter) n))) (let ((half (beside (flip-horiz quarter) quarter))) (below (flip-vert half) half))))","title":"Exercise 2.52"},{"location":"2-building-abstractions-with-data/#23-symbolic-data","text":"","title":"2.3 Symbolic Data"},{"location":"2-building-abstractions-with-data/#exercise-253","text":"(list 'a 'b 'c) ; ==> (a b c) (list (list 'george)) ; ==> ((george)) (cdr '((x1 x2) (y1 y2))) ; ==> ((y1 y2)) (cadr '((x1 x2) (y1 y2))) ; ==> (y1 y2) (pair? (car '(a short list))) ; ==> #f (memq 'red '((red shoes) (blue socks))) ; ==> #f (memq 'red '(red shoes blue socks)) ; ==> (red shoes blue socks)","title":"Exercise 2.53"},{"location":"2-building-abstractions-with-data/#exercise-254","text":"(define (equal? x y) (cond ((and (null? x) (null? y)) #t) ((or (null? x) (null? y)) #f) (else (and (eq? (car x) (car y)) (equal? (cdr x) (cdr y)))))) (equal? (list 'a 'b 'c) (list 'a 'b 'c)) ; #t (equal? (list 'a 'b 'c) (list 'a 'b 'c 'd)) ; #f","title":"Exercise 2.54"},{"location":"2-building-abstractions-with-data/#exercise-255","text":"Consider that 'abracadabra provides the symbol abracadabra . It is interesting to note what ''abracadabra (representing the symbol of the symbol abracadabra ) yields: 'abracadabra ; ==> abracadabra ''abracadabra ; ==> (quote abracadabra) Consider then that 'a is actually a shorthand for (quote a) . Because of this, ''a is simply '(quote a) , which would yield (quote a) . (car ''abracadabra) ; (car '(quote abracadabra)) ; ==> quote","title":"Exercise 2.55"},{"location":"2-building-abstractions-with-data/#exercise-256","text":"(define (make-exponentiation b e) (cond ((=number? e 0) b) ((=number? b 1) 1) ((and (number? b) (number? e)) (expt b e)) (else (list '** b e)))) (define (exponentiation? x) (and (pair? x) (eq? (car x) '**))) (define (base e) (cadr e)) (define (exponent e) (caddr e)) (define (deriv exp var) (cond ; other conditions go here ((exponentiation? exp) (make-product (make-product (exponent exp) (make-exponentiation (base exp) (- (exponent exp) 1))) (deriv (base exp) var))) (else (error \"unknown expression type: DERIV\" exp))))","title":"Exercise 2.56"},{"location":"2-building-abstractions-with-data/#exercise-257","text":"I had to weed out the constants from addends and separating their sum from the remaining elements. In addition, I had to change the definition of augend to allow for arbitrary-length expressions: ; make-sum creates a sum from variadic parameter addends. ; Sums first the constants and then creates this recursive definition ; such that (a+b+c) == (a+(b+c)). (define (make-sum . addends) ; sum-constantless sums addends recursively ; where addends has no constant. (define (sum-constantless addends) (if (= (length addends) 1) (car addends) (list '+ (car addends) (sum-constantless (cdr addends))))) (let ((constants-sum (accumulate + 0 (filter number? addends))) (remaining (filter (lambda (x) (not (number? x))) addends))) (cond ((null? remaining) constants-sum) ((= constants-sum 0) (sum-constantless remaining)) (else (list '+ constants-sum (sum-constantless remaining)))))) (define (sum? x) (and (pair? x) (eq? (car x) '+))) (define (addend s) (cadr s)) (define (augend s) (if (= (length (cddr s)) 1) (caddr s) (apply make-sum (cddr s)))) A similar process is going on with make-product ; make-product returns a product from a set of factors (define (make-product . factors) ; product-constantless multiplies recursively where factors has no constant (define (product-constantless factors) (if (= (length factors) 1) (car factors) (list '* (car factors) (product-constantless (cdr factors))))) (let ((constants-product (accumulate * 1 (filter number? factors))) (remaining (filter (lambda (x) (not (number? x))) factors))) (cond ((null? remaining) constants-product) ((= constants-product 0) 0) ((= constants-product 1) (product-constantless remaining)) (else (list '* constants-product (product-constantless remaining)))))) (define (product? x) (and (pair? x) (eq? (car x) '*))) (define (multiplier p) (cadr p)) (define (multiplicand p) (if (= (length (cddr p)) 1) (caddr p) (apply make-product (cddr p))))","title":"Exercise 2.57"}]}